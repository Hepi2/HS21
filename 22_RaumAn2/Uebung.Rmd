```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,include = TRUE,message = FALSE, collapse=TRUE, warnings = FALSE) 
```

## Übung

Beginne damit, die Kantonsgrenzen von letzter Woche sowie einen neuen Datensatz `rotmilan` zu importieren. Lade vorher aber die notwendigen Libraries und setze anschliessend das Korrekte CRS.

- [kantone.gpkg](21_RaumAn1/data/kantone.gpkg)
- [rotmilan.gpkg](21_RaumAn1/data/kantone.gpkg)

Der Datensatz `rotmilan` stammt aus einem grösseren Forschungsprojekt der Vogelwarte Sempbach [Mechanismen der Populationsdynamik beim Rotmilan](https://www.vogelwarte.ch/de/projekte/oekologische-forschung/mechanismen-der-populationsdynamik-beim-rotmilan). Der Datensatz wurde über die Plattform [movebank](http://www.movebank.org/panel_embedded_movebank_webapp?gwt_fragment=page%3Dsearch_map_linked%2CindividualIds%3D676571254%2Clat%3D44.465151013519666%2Clon%3D9.096679687499508%2Cz%3D5) zur Verfügung gestellt. Es handelt sich dabei um ein einzelndes Individuum, welches seit 2017 mit einem Sender versehen ist und über ganz Mitteleuropa zieht. Wir arbeiten in dieser Übung nur mit denjenigen Datenpunkten, die in der Schweiz erfasst wurden. Wer den ganzen Datensatz analysieren möchte, kann sich diesen über den Movebank-Link runterladen.


```{r}
library(sf)
library(tidyverse)
library(lubridate)
library(cowplot)
library(stars)


kantone <- read_sf("21_RaumAn1/data/kantone.gpkg")
rotmilan <- read_sf("22_RaumAn2/data/rotmilan.gpkg")



kantone <- st_set_crs(kantone,2056)
rotmilan <- st_set_crs(rotmilan, 2056)



```


```{r}

as(rotmilan,"Spatial")

st_kde <- function(points,cellsize, bandwith, extent = NULL){
  require(MASS)
  require(raster)
  require(sf)
  if(is.null(extent)){
    extent_vec <- st_bbox(points)[c(1,3,2,4)]
  } else{
    extent_vec <- st_bbox(extent)[c(1,3,2,4)]
  }
  
  n_y <- ceiling((extent_vec[4]-extent_vec[3])/cellsize)
  n_x <- ceiling((extent_vec[2]-extent_vec[1])/cellsize)
  
  extent_vec[2] <- extent_vec[1]+(n_x*cellsize)-cellsize
  extent_vec[4] <- extent_vec[3]+(n_y*cellsize)-cellsize

  coords <- st_coordinates(points)
  matrix <- kde2d(coords[,1],coords[,2],h = bandwith,n = c(n_x,n_y),lims = extent_vec)
  raster(matrix)
}

```

### Aufgabe x: Rotmilan Bewegungsdaten visualisieren

Eine der ersten Fragen die bei solchen Bewegungsstudien gestellt werden lautet: *Wo haltet sich das Tier hauptsächlich auf?* Um diese Frage zu Beantworten kann man als erstes einfach die Datenpunkte in einer einfachen Karte Visualisieren.

```{r}
ggplot(kantone) + 
  geom_sf() + 
  geom_sf(data = rotmilan) +
  theme_void()
```

In einer ersten annnäherung funktioniert dies, doch wir sehen hier ein klassisches Problem des "overplotting". Das heisst, dass wir durch die Überlagerung vieler Punkte in den dichten Regionen nicht abschätzen können, 


```{r}
ggplot(kantone) + 
  geom_sf() + 
  geom_sf(data = rotmilan, aes(colour = factor(year(timestamp))),show.legend = 'point') +
  labs(colour = "Jahr")+
  theme_void()
```


```{r}
rotmilan$year <- year(rotmilan$timestamp)

ggplot(kantone) + 
  geom_sf() + 
  geom_sf(data = rotmilan) +
  theme_void()+
  facet_wrap(~year)
```


### Aufgabe x: Dichteverteilung der Punkte mit KDE

```{r}
rotmilan_kde <- st_kde(rotmilan,cellsize = 1000,bandwith = 10000,kantone)


ggplot() + 
  geom_stars(data = st_as_stars(rotmilan_kde)) +
  geom_sf(data = kantone, fill = NA) +
  scale_fill_viridis_c(limits = c(5e-11,NA),na.value = NA) +
  theme_void() +
  theme(legend.position = "none")

```


### Aufgabe x: Dichteverteilung nach Jahr


```{r}

rotmilan_kdes <- rotmilan %>%
  split(.$year) %>%
  map(~st_kde(.x,cellsize = 1000,bandwith = 10000,kantone))


plts <- imap(rotmilan_kdes,function(x,y){
  ggplot() + 
  geom_stars(data = st_as_stars(x)) +
  geom_sf(data = kantone, fill = NA) +
  scale_fill_viridis_c(limits = c(5e-11,NA),na.value = NA) +
  theme_void()+
  labs(tag = y) +
  theme(legend.position = "none")
})

cowplot::plot_grid(plotlist = plts)


```


