```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,include = TRUE,message = FALSE, collapse=TRUE, warnings = FALSE) 
```

## Übung A: Interpolationen

Daten importieren, CRS zuweisen

- [luftqualitaet.gpkg](22_RaumAn2/data/luftqualitaet.gpkg) Luftqualitätsmessungen, NO2, [weitere Infos](https://opendata.swiss/en/dataset/luftqualitaet)
- [kantone.gpkg](21_RaumAn1/data/kantone.gpkg): Ein Datensatz der Swisstopo ([weitere Informationen](https://shop.swisstopo.admin.ch/de/products/landscape/boundaries3D))


```{r, echo = TRUE}
library(gstat)
library(sf)
library(tidyverse)
library(lubridate)
library(cowplot)
library(stars)

luftqualitaet <- read_sf("22_RaumAn2/data/luftqualitaet.gpkg")
kantone <- read_sf("21_RaumAn1/data/kantone.gpkg")


luftqualitaet <- st_set_crs(luftqualitaet,2056)
kantone <- st_set_crs(kantone, 2056)
```



### Aufgabe X: Räumliche Interpolation mit IDW

Die Library `spatstat` bietet verschiedene Möglicheiten, Datenpunkte zu interpolieren. Das Schema ist dabei immer gleich: man erstellt zuerst einen Punktdatensatz, für um diejenigen Orte bestimmen, wo man gerne Messert hätte. Wenn man 

```{r, echo = TRUE}
samples <- st_sample(kantone,size = 2000,type = "regular")

samples <- st_set_crs(samples, 2056)

luftqualitaet_idw <- gstat::idw(formula = value~1,
                                locations = luftqualitaet,
                                newdata = samples,
                                nmax = 10, 
                                idp = 1)

ggplot(luftqualitaet) +
  geom_sf(aes(colour = value)) +
  geom_sf(data = luftqualitaet_idw, aes(colour = var1.pred)) +
  scale_colour_viridis_c()
```

In unserem Fall machte es mehr Sinn, die Datenpunkte als `raster` darzustellen. Dafür machen wir nicht extra einen `RasterLayer` wie letzte Woche, sondern ergänzen den Datensatz `luftqualitaet_idw` mit X/Y Koordinaten *in spalten* und übergeben dies `ggplot` mit `geom_rater()`.


```{r, echo = TRUE}

luftqualitaet_idw <- luftqualitaet_idw %>%
  st_coordinates(luftqualitaet_idw) %>%
  cbind(luftqualitaet_idw)

luftqualitaet_idw

ggplot(data = luftqualitaet_idw, aes(X,Y, fill = var1.pred)) + 
  geom_tile() +
  coord_equal() +
  scale_fill_viridis_c()

```


<!-- todo: hier noch verschiedene varianten mit maxdist, blocksize usw. testen. -->

```{r}
luftqualitaet_idw <- gstat::idw(formula = value~1,
                                locations = luftqualitaet,
                                newdata = samples,
                                nmax = 10, 
                                idp = 2)

luftqualitaet_idw %>%
  st_coordinates(luftqualitaet_idw) %>%
  cbind(luftqualitaet_idw) %>%
  ggplot(aes(X,Y, fill = var1.pred)) + 
  geom_tile() +
  coord_equal() +
  scale_fill_viridis_c()
  
```


### Interpolation mit Nearest Neighbour

Eine Möglichkeit zu Interpolation bietet die Erstellung eines Voronoi-Diagrammes, auch als Thiessen-Polygone oder Dirichlet-Zerlegung bekannt. `sf` liefert dazu die Funktion `st_voronoi()`, die einen Punktdatensatz annimmt und eben eine solche Thiessenpolygone zurück gibt. Dazu braucht es lediglich einen kleinen Vorprozessierungsschritt: `sf` möchte für jedes Feature, also für jede *Zeile* in unserem Datensatz ein Voronoidiagramm erstellen. Das macht bei uns wenig sinn, weil jede Zeile nur aus einem Punkt besteht. Deshalb müssen wir vorher `rotmilan` mit `st_union()` von einem `POINT` in ein `MULTIPOINT` objekt konvertieren, wo alle Punkte in einer Zeile zusammengefasst sind. 

```{r, echo = TRUE}

luftqualitaet_union <- st_union(luftqualitaet)

thiessenpolygone <- st_voronoi(luftqualitaet_union)

thiessenpolygone <- st_set_crs(thiessenpolygone, 2056)

ggplot() + 
  geom_sf(data = kantone) +
  geom_sf(data = thiessenpolygone, fill = NA)

```

`st_voronoi` hat die Thiessenpolygone etwas weiter gezogen als wir sie wollen. Wir können die Polygone auf die Ausdehnung der Schweiz mit `st_intersection()` clippen. Auch hier braucht es zwei kleine Vorprozessierungsschritte:

1. wie vorher müssen wir die einzelnen Kantonspolyonge miteinander verschmelzen. Dies erreichen wir mit `st_union()` und speichern den Output als `schweiz`, das das Resultat ein einzelnes Polygon der Schweizer Grenze darstellt.
2. für die Thiessenpolygone machen wir genau das Umgekehrte: `st_voronoi()` lieferte ein einzelnes Feature mit allen Polygonen, welches sich nicht gerne clippen lässt. Mit `st_cast()` wird die `GEOMETRYCOLLECTION` in Einzelpolygone aufgeteilt. 

```{r, echo = TRUE}
schweiz <- st_union(kantone)
thiessenpolygone <- st_cast(thiessenpolygone)

thiessenpolygone_clip <- st_intersection(thiessenpolygone,schweiz)

ggplot() + 
  geom_sf(data = kantone) +
  geom_sf(data = thiessenpolygone_clip, fill = NA)

```

jetzt müssen wir nur noch den jeweiligen Wert für jedes Polygon ermitteln. Dies erreichen wir wieder durch `st_join`. Auch hier ist noch ein *kleiner* Vorbereitungsschritt nötig: wir konvertieren das `sfc` objekt (nur Geometrien) in ein `sf` objekt (Geometrien mit Attributtabelle).

```{r, echo = TRUE}

thiessenpolygone_clip <- st_as_sf(thiessenpolygone_clip)
thiessenpolygone_clip <- st_join(thiessenpolygone_clip,luftqualitaet)

ggplot() + 
  geom_sf(data = kantone) +
  geom_sf(data = thiessenpolygone_clip, aes(fill = value)) +
  scale_fill_viridis_c() +
  theme_void()
```


## Übung B: Dichteverteilung

Beginne damit, die Kantonsgrenzen von letzter Woche sowie einen neuen Datensatz `rotmilan` zu importieren. Lade vorher aber die notwendigen Libraries und setze anschliessend das Korrekte CRS.

- [kantone.gpkg](21_RaumAn1/data/kantone.gpkg)
- [rotmilan.gpkg](21_RaumAn1/data/kantone.gpkg)

Der Datensatz `rotmilan` stammt aus einem grösseren Forschungsprojekt der Vogelwarte Sempbach [Mechanismen der Populationsdynamik beim Rotmilan](https://www.vogelwarte.ch/de/projekte/oekologische-forschung/mechanismen-der-populationsdynamik-beim-rotmilan). Der Datensatz wurde über die Plattform [movebank](http://www.movebank.org/panel_embedded_movebank_webapp?gwt_fragment=page%3Dsearch_map_linked%2CindividualIds%3D676571254%2Clat%3D44.465151013519666%2Clon%3D9.096679687499508%2Cz%3D5) zur Verfügung gestellt. Es handelt sich dabei um ein einzelndes Individuum, welches seit 2017 mit einem Sender versehen ist und über ganz Mitteleuropa zieht. Wir arbeiten in dieser Übung nur mit denjenigen Datenpunkten, die in der Schweiz erfasst wurden. Wer den ganzen Datensatz analysieren möchte, kann sich diesen über den Movebank-Link runterladen.


```{r}



rotmilan <- read_sf("22_RaumAn2/data/rotmilan.gpkg")



kantone <- st_set_crs(kantone,2056)
rotmilan <- st_set_crs(rotmilan, 2056)



```





### Aufgabe x: Rotmilan Bewegungsdaten visualisieren

Eine der ersten Fragen die bei solchen Bewegungsstudien gestellt werden lautet: *Wo haltet sich das Tier hauptsächlich auf?* Um diese Frage zu Beantworten kann man als erstes einfach die Datenpunkte in einer einfachen Karte Visualisieren.

```{r}
ggplot(kantone) + 
  geom_sf() + 
  geom_sf(data = rotmilan) +
  theme_void()
```




### Aufgabe x: Kernel Density Estimation

In einer ersten annnäherung funktioniert dies, doch wir sehen hier ein klassisches Problem des "overplotting". Das heisst, dass wir durch die Überlagerung vieler Punkte in den dichten Regionen nicht abschätzen können, wie viele Punkte dort liegen. Es gibt hier verschiedene Möglichkeiten, die Punktdichte klarer zu Visualisieren. Eine unter biologen sehr beliebte Methode ist die Dichteverteilung mit einer Kernel Density Estimation. Homeranges werden oft mit KDE95 und Core Areas mit KDE50 definiert. Kernel Density Estimations werden in vielen Bereichen angewendet um Kurven zu Glätten (?), meist sind sie ein- und nicht zweidimensional.

Leider existiert in `sf` noch keine `st_kde()` Funktion. Damit wir dieses Verfahren aber dennoch auf unsere Rotmilan-Daten anwenden können, haben wir eine eigene KDE-Funktion erstellt die wir euch zur Verfügung stellen. Die Funktion beruht auf den Libraries `MASS`, `raster` und `sf`, und `stars`. Die letzen drei solltet ihr bereits installiert haben, überprüft, ob `MASS` ebenfalls schon installiert ist und holt dies bei bedarf nach. Im Anschluss könnt ihr die nachstehende Funktion einlesen:

```{r}
st_kde <- function(points,cellsize, bandwith, extent = NULL){
  require(MASS)
  require(raster)
  require(sf)
  require(stars)
  if(is.null(extent)){
    extent_vec <- st_bbox(points)[c(1,3,2,4)]
  } else{
    extent_vec <- st_bbox(extent)[c(1,3,2,4)]
  }
  
  n_y <- ceiling((extent_vec[4]-extent_vec[3])/cellsize)
  n_x <- ceiling((extent_vec[2]-extent_vec[1])/cellsize)
  
  extent_vec[2] <- extent_vec[1]+(n_x*cellsize)-cellsize
  extent_vec[4] <- extent_vec[3]+(n_y*cellsize)-cellsize

  coords <- st_coordinates(points)
  matrix <- kde2d(coords[,1],coords[,2],h = bandwith,n = c(n_x,n_y),lims = extent_vec)
  raster(matrix)
}
```


Die Parameter der Funktion sollten relativ klar sein:

- points: Ein Punktdatensatz aus der Class `sf`
- cellsize: Die Zellgrösse des output-Rasters
- bandwith: Der Suchradius für die Dichteberechnung
- extent (optional): Der Perimeter, in dem die Dichteverteilung berechnet werden soll. Wenn kein Perimeter angegeben wird, wird die "bounding box" von `points` genutzt.

Wenn wir nun mit `st_kde()` die Dichteverteilung berechnen, erhalten wir einen Raseterdatensatz zurück der sich mit `base::plot()` schnell visualisieren lässt.

```{r}
rotmilan_kde <- st_kde(rotmilan,cellsize = 1000,bandwith = 10000,schweiz)

rotmilan_kde

plot(rotmilan_kde)
```

Um den raster Datensatz in `ggplot()` to integrieren müssen wir ihn zu einerm `stars` objekt konvertieren und können danach `geom_stars()` verwenden.

```{r}
ggplot() + 
  geom_stars(data = st_as_stars(rotmilan_kde)) +
  geom_sf(data = kantone, fill = NA) +
  scale_fill_viridis_c() +
  theme_void() +
  theme(legend.position = "none")
```

Die Kernel Density estimation ist nun sehr stark von den tiefen Werten dominiert, da die Dichte in den meisten Zellen unseres Untersuchungsgebiets nahe bei Null liegt. Das sieht man auch sehr deutlich, wenn wir die Rasterzellenwerte als Boxplot oder Histogramm darstellen. 


```{r}
par(mfrow = c(1,2))
hist(rotmilan_kde)
boxplot(rotmilan_kde)
```

Wir können die tiefen Werte ausblednen, indem wir nur die höchsten 5% der Werte darstellen dafür berechnen wir mit `raster::quantile` die 95. Perzentile aller Rasterzellen und nutzen dies um die Farbskale in `ggplot` zu limitieren. Zusätzlich hilft eine logarithmische Transformation der KDE-Werte die Farbskala etwas sichtbarer zu machen.

```{r}
q95 <- raster::quantile(rotmilan_kde,probs = 0.95)

ggplot() + 
  geom_sf(data = kantone, fill = NA) +
  geom_stars(data = st_as_stars(rotmilan_kde),alpha = 0.8) +
  scale_fill_viridis_c(trans = "log10",limits = c(q95,NA),na.value = NA) +
  theme_void() +
  labs(fill = "KDE",title = "Dichteverteilung von Bewegungsdaten eines Rotmilans",subtitle = "Jahre 2017-2019") +
  theme(legend.position = "top", legend.direction = "horizontal")
```



### Aufgabe x: Thiessen Polygone


<!-- raus nehmen?? -->

```{r, echo = TRUE}

thiessenpolygone <- rotmilan %>%
  st_union() %>%
  st_voronoi()



ggplot() + 
  geom_sf(data = kantone) + 
  geom_sf(data = thiessenpolygone, fill = NA) + 
  geom_sf(data = rotmilan) +
  theme_void()


```






```{r, echo = TRUE}
schweiz <- st_union(kantone)


thiessenpolygone

thiessenpolygone <- st_cast(thiessenpolygone)

thiessenpolygone

# Dieser Schritt kann eine Weile dauern
thiessenpolygone_clip <- st_intersection(thiessenpolygone,schweiz)

```


Wenn wir jetzt die Thiessenpolygone (ohne Punkte) darstellen wird deutlicher, wie die Dichteverteilung im innern des Clusters aussieht. 

```{r}

ggplot() + 
  geom_sf(data = schweiz) + 
  geom_sf(data = thiessenpolygone_clip) + 
  theme_void()

```




