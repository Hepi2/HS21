[
["index.html", "Research Methods Kapitel 1 Einleitung", " Research Methods 2019-11-25 Kapitel 1 Einleitung Das Modul „Research Methods“ vermittelt vertiefte Methodenkompetenzen für praxisorientiertes und angewandtes wissenschaftliches Arbeiten im Fachbereich „Umwelt und Natürliche Ressourcen“ auf MSc-Niveau. Die Studierenden erarbeiten sich vertiefte Methodenkompetenzen für die analytische Betrachtung der Zusammenhänge im Gesamtsystem „Umwelt und Natürliche Ressourcen“. Die Studierenden erlernen die methodischen Kompetenzen, auf denen die nachfolgenden Module im MSc Programm UNR aufbauen. Das Modul vermittelt einerseits allgemeine, fächerübergreifende methodische Kompetenzen (z.B. Wissenschaftstheorie, computer-gestützte Datenverar-beitung und Statistik). Auf dieser Plattform (RStudio Connect) werden die Unterlagen für die R-Übungsteile bereitgestellt. Es werden sukzessive sowohl Demo-Files, Aufgabenstellungen und Lösungen veröffentlicht. "],
["2-raumanalyse-1-25-11-2019.html", "Kapitel 2 Raumanalyse 1 (25.11.2019)", " Kapitel 2 Raumanalyse 1 (25.11.2019) Die erste Übung zur Raumanalyse illustriert das einfache Laden und Anzeigen von Geodaten im Vektor- und Raster-Datenformat. Zusätzlich veranschaulicht die Übung den Umgang mit Koordinatensystemen sowie die Vektor-Raster-Konvertierung. Einfach erste Analysen umfassen den Spatial Join (Annotieren von Punkten mit Attributen von die Punkte einbettenden Vektordaten) sowie Puffer-Operationen. Zum Abschluss thematisiert die Übung die Aggregationsabhängigkeit räumlicher Daten durch die Illustration des Modifiable Areal Unit Problem (MAUP). Inhaltlich orientiert sich die Übung an Bodeneigenschaften für den Untersuchungsraum Schweiz. "],
["2-1-ubung-spatial-join-puffer-und-maup.html", "2.1 Übung: Spatial Join, Puffer und MAUP", " 2.1 Übung: Spatial Join, Puffer und MAUP 2.1.1 Themantische Einbettung Mit dieser Übung wirst Du Schritt fürfür Schritt an einfache Methoden der Raumanalyse herangeführt. Dies umfasst das Laden und Plotten von Vektor- und Rasterdaten sowie den wichtigen Umgang mit Koordinatensystemen. Darauf folgen einige Übungen zur räumlichen Anreicherung von Punktdaten unter Verwendung des Konzepts des “Spatial Join”. Dazu arbeiten wir mit einem Datensatz aus Punktstichproben zur Wasserverfügbarkeit in Schweizer Böden. Es soll untersucht werden, ob ein Zusammenhang besteht zwischen der an den Punkten gemessenen Wasserverfügbarkeit und dem Join-Layer Bodeneignung/Skelettanteil. Im zweiten Teil der Übung wirst Du die Messwerte zur Wasserverfügbarkeit auf unterschiedlichen räumlichen Skalen aggregieren (Kantone, Bezirke und Gemeinden) und prüfen, ob ggf. das Modifiable Areal Unit Problem auftritt. 2.1.2 Vorbereitung Es gibt bereits eine Vielzahl von Packages um in R mit räumlichen Daten zu arbeiten, die ihrerseits wiederum auf weiteren Packages basieren (Stichwort dependencies). Für Vektordaten dominierte lange das Package sp, welches nun aber schrittweise durch sf abgelöst wird. Wir werden wenn immer möglich mit sf arbeiten und nur in Ausnahmefällen auf andere Packages zurück greifen. Für Rasterdaten exisitert das Package raster Für die Integration von Vektor und Rasterdaten existiert das Package starts: Spatiotemporal Arrays for Raster and Vector Datacubes. Diese Tools sind teilweise sehr gut dem Tidyverse-Workflow (group_by, mutate, summarise, %&gt;%) integriert. Lade zu beginn die folgenden notwenigen Packages (installiere die fehlenden Packages mit install.package(&quot;packagename&quot;)). library(sf) library(tidyverse) library(stars) library(raster) 2.1.3 Aufgabe 1: Daten runterladen und importieren Lade zunächst die Datensätze unter folgenden Links herunter und importiere sie mit dem Befehl read_sf() in R: bodeneignung_skelett.gpkg: Datensatz des Bundesamt für Landwirtschaft, modifiziert (weitere Informationen) kantone.gpkg: Ein Datensatz der Swisstopo, modifiziert (weitere Informationen) bezirke.gpkg: Ein Datensatz der Swisstopo, modifiziert (weitere Informationen) wasserverfuegbarkeit_boden.gpkg: Ein Datensatz der WSL, modifiziert (weiteren Informationen) Es handelt sich um Geodatensätze im Format Geopackage (“*.gpkg”), eine alternatives Datenformat zum bekannteren Format “Shapefiles”. Lade nun die Datensätze wie folgt ein: # Pfad muss natürlich angepasst werden wasser &lt;- read_sf(&quot;21_RaumAn1/data/wasserverfuegbarkeit_boden.gpkg&quot;) kantone &lt;- read_sf(&quot;21_RaumAn1/data/kantone.gpkg&quot;) bezirke &lt;- read_sf(&quot;21_RaumAn1/data/bezirke.gpkg&quot;) gemeinden &lt;- read_sf(&quot;21_RaumAn1/data/gemeinden.gpkg&quot;) skelettgehalt &lt;- read_sf(&quot;21_RaumAn1/data/bodeneignung_skelett.gpkg&quot;) Schau Dir die importierten Datensätze an, nutzt dafür View(), str(), class(). Studiere ausserdem die weiteren Informationen zu den Datensätzen. 2.1.4 Aufgabe 2: Daten Visualisieren Wir hatten anfangs erwähnt, dass Geodaten mit sf und raster sich teilweise sehr schön in die bekannten Tidyverse workflows integrieren lassen. Das merkt man schnell, wenn man die Daten visualisieren möchte. In InfoVis 1 &amp; 2 haben wir intensiv mit ggplot2 gearbeitet und dort die Layers geom_point() und geom_line() kennen gelernt. Zusätzlich beinhaltet ggplot die Möglichkeit, mit geom_sf() Vektordaten direkt und sehr einfach zu plotten. Führe die angegebenen R-Befehle aus und studiere die entstehenden Plots. Welche Unterschiede findest Du? Wie erklärst Du diese Unterschiede? ggplot(bezirke) + geom_sf() ggplot(wasser) + geom_sf() 2.1.5 Aufgabe 3 Koordinatensysteme zuweisen In den obigen beiden sehr einfachen Kartogrammen fallen verschiedene Dinge auf: die X/Y Achsen weisen zwei ganz unterschiedlichen Zahlenbereiche auf (vergleiche die Achsenbeschriftungen), und der Umriss der Schweiz scheint im zweiten Plot “gestaucht” zu sein. Dies hat natürlich damit zu tun, dass die beiden Datensätze in unterschiedlichen Koordinatensystemen erfasst wurden. Koordinatensysteme werden mit CRS (Coordinate Reference System) abgekürzt. Mit st_crs() könnnen die zugewiesenen Koordinatensysteme abgefragt werden. st_crs(wasser) ## Coordinate Reference System: NA st_crs(bezirke) ## Coordinate Reference System: NA Leider sind in unserem Fall keine Koordinatensysteme zugewiesen. Mit etwas Erfahrung kann man das Koordinatensystem aber erraten, so viele kommen nämlich gar nicht in Frage. Am häufigsten trifft man hierzulande eines der drei folgenden Koordinatensysteme an: CH1903 LV03: das alte Koordinatensystem der Schweiz CH1903+ LV95: das neue Koordinatensystem der Schweiz WGS84: ein häufig genutztes weltumspannendes geodätisches Koordinatensystem, sprich die Koordinaten werden in Länge und Breite angegeben (Lat/Lon). Nun gilt es, anhand der Koordinaten die in der Spalte geometry ersichtlich sind das korrekte Koordinatensystem festzustellen. Wenn man sich auf epsg.io/map die Schweiz anschaut, kann man die Koordinaten in verschiedenen Koordinatensystem betrachten. Bedienungshinweise: Koordinanten (des Fadenkreuzes) werden im ausgewählten Koordinatensystem dargestellt Das Koordinatensystem, in welchem die Koordinaten dargestellt werden sollen, kann mit “Change” angepasst werden Für Enthusiasten: Schau Dir die Schweiz in verschiedenen Koordinatensystemen an, in dem Du auf “Reproject Map” klickst Wenn man diese Koordinaten mit den Koordinaten unserer Datensätze vergleicht, dann ist schnell klar, dass es sich beim Datensatz wasser um das Koordinatensystem WGS84 handelt und bei bezirke das Koordinatensystem CH1903+ LV95. Diese Koordinatensyteme weisen wir nun mit st_set_crs() und dem entsprechenden EPSG-Code (siehe die jeweiligen Links) zu. wasser &lt;- st_set_crs(wasser, 4326) bezirke &lt;- st_set_crs(bezirke, 2056) # zuweisen mit st_set_crs(), abfragen mit st_crs() st_crs(wasser) ## Coordinate Reference System: ## EPSG: 4326 ## proj4string: &quot;+proj=longlat +datum=WGS84 +no_defs&quot; Weise auch für die anderen Datensätze (kantone, gemeinden, skelettgehalt) das korrekte Koordinatensytem zu. Jetzt wo das CRS der Datensätze bekannt ist, können diese in einem gemeinsamen Plot visualisiert werden, ggplot kümmert sich darum die unterschiedlichen Koordinatensysteme zu vereinheitlichen. Probier das aus, indem du kantone und wasser in einem ggplot kombinierst. Die Achsen werden dann immer in WGS84 beschriftet. Wenn das stört, kann man coord_sf(datum = 2056) in einem weiteren Layer spezifizieren. Oder aber man blendet die Achsenbeschriftung mit theme_void() komplett aus. Versuche beide Varianten. 2.1.6 Aufgabe 4: Koordinatensyteme transformieren In der vorherigen Übung haben wir das bestehende Koordinatensystem zugewiesen. Dabei haben wir die bestehenden Koordinaten (in der Spalte geom) nicht manipuliert. Ganz anders ist eine Transformation der Daten von einem Koordinatensystem in das andere. Bei einer Transformation werden die Koordinaten in das neue Koordinatensystem umgerechnet und somit manipuliert. Aus praktischen Gründen wollen wir all unsere Daten ins neue Schweizer Koordinatensystem CH1903+ LV95 transfomieren. Transformiere den Datensatz wasser mit st_transform()in CH1903+ LV95, nutze dafür den korrekten EPSG-Code. Vor der Transformation (betrachte die Spalte geom sowie die Attribute epsg (SRID) und proj4string): wasser ## Simple feature collection with 993 features and 1 field ## geometry type: POINT ## dimension: XY ## bbox: xmin: 6.006132 ymin: 45.84509 xmax: 10.46693 ymax: 47.76851 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs ## # A tibble: 993 x 2 ## wasserverfuegbarkeit geom ## &lt;dbl&gt; &lt;POINT [°]&gt; ## 1 -167 (8.997155 45.84509) ## 2 0 (7.072459 45.91802) ## 3 0 (7.153695 45.90636) ## 4 0 (7.251192 45.91059) ## 5 0 (7.380257 45.92894) ## 6 0 (7.423909 45.92544) ## 7 0 (9.013727 45.91338) ## 8 -91 (9.051913 45.89967) ## 9 0 (7.069596 45.9689) ## 10 -102 (7.175481 45.9782) ## # … with 983 more rows Nach der Transformation (betrachte die Spalte geom): wasser ## Simple feature collection with 993 features and 1 field ## geometry type: POINT ## dimension: XY ## bbox: xmin: 2489453 ymin: 1078252 xmax: 2830887 ymax: 1291537 ## epsg (SRID): 2056 ## proj4string: +proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +k_0=1 +x_0=2600000 +y_0=1200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs ## # A tibble: 993 x 2 ## wasserverfuegbarkeit geom ## &lt;dbl&gt; &lt;POINT [m]&gt; ## 1 -167 (2721079 1078252) ## 2 0 (2571587 1085224) ## 3 0 (2577885 1083902) ## 4 0 (2585453 1084350) ## 5 0 (2595470 1086373) ## 6 0 (2598856 1085983) ## 7 0 (2722214 1085868) ## 8 -91 (2725207 1084404) ## 9 0 (2571392 1090881) ## 10 -102 (2579603 1091882) ## # … with 983 more rows 2.1.7 Aufgabe 5: Wir wollen nun wissen, ob die Wasserverfügbarkeit im Boden mit dem Skelettgehalt zusammen hängt. Dazu nutzen wir die GIS-Technik Spatial Join, die in der Vorlesung beschrieben wurde. In sf können wir Spatial Joins mit der Funktion st_join durchführen, dabei gibt es nur left sowie inner-Joins (vgl. PrePro 1 &amp; 2). So müssen die Punkte “Links”, also an erste Stelle aufgeführt werden, da wir ja Attribute an die Punkte anheften wollen. ## Simple feature collection with 993 features and 2 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 2489453 ymin: 1078252 xmax: 2830887 ymax: 1291537 ## epsg (SRID): 2056 ## proj4string: +proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +k_0=1 +x_0=2600000 +y_0=1200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs ## # A tibble: 993 x 3 ## wasserverfuegbarkeit geom SKELETT ## &lt;dbl&gt; &lt;POINT [m]&gt; &lt;dbl&gt; ## 1 -167 (2721079 1078252) 3 ## 2 0 (2571587 1085224) NA ## 3 0 (2577885 1083902) NA ## 4 0 (2585453 1084350) NA ## 5 0 (2595470 1086373) NA ## 6 0 (2598856 1085983) NA ## 7 0 (2722214 1085868) 4 ## 8 -91 (2725207 1084404) 4 ## 9 0 (2571392 1090881) NA ## 10 -102 (2579603 1091882) 4 ## # … with 983 more rows Führe den obigen Spatial Join aus und erstelle anschliessend einen Boxplot pro Skelett-Kategorie. Für ggplot boxplots ist es sinnvoll, den Skelettgehalt vorgängig von numeric in factor zu konvertieren (falls Du nicht mehr weisst weshalb, schau nochmals nach in PrePro und InfoVis). Nun haben wir das Ziel der Aufgabe erreicht und die Messpunkte durch räumliche Zusatzinformation aufgewertet. Wir werden das Resultat an dieser Stelle aber nicht weiter interpretieren, dass wäre Teil einer Bodenkunde Vorlesung. 2.1.8 Aufgabe 6: Spatial Join mit Flächen In der letzten Aufgabe haben wir für jede Probe aus wasser den Skelettgehalt des darunterliegenden Polygons ermittelt. Für Proben, die gerade an der Grenze zu einem Polygon mit einem anderen Skelettgehalt liegen ist dieser Wert aber nicht sehr aussagekräftig. So könnte es zum Beispiel wichtiger sein zu wissen, was der dominierende Skelettgehalt innerhalb eines 2 km Radius um die Probe ist. In den kommenden Teilaufgaben lösen wir diese Herausforderung. 2.1.8.1 Teilaufgabe A: Punkte mit Puffer versehen Dafür müssen wir die Punkte mit einem Puffer versehen. Dies erreichen wir mit st_buffer(). Erstelle einen Datensatz wasser_2km, in dem jeder Punkt mit 2’000 m gepuffert wurde. Visualisiere dann diesen Datensatz. Beachte, dass es sich nun nicht mehr um Punkte, sondern um Flächen handelt (POLYGON). 2.1.8.2 Teilaufgabe B: Vektordatensatz in Raster konvertieren Um Flächen miteinander zu verrechnen (“Was ist der dominierende Skelettgehalt im Umkreis von 2km?”) ist es einfacher, wenn der Skelettgehalt-Datensatz im Raster-Datenformat daher kommt. Dazu wandeln wir den Vektordatensatz skelettgehalt mit einer Vektor-nach-Raster-Konvertierung in den Rasterdatensatz skelett_raster. Hierzu brauchen wir die Funktion fasterize() (fast rasterize) aus der gleichnamigen Library. Installiere diese Library (wenn nötig) und importiere sie in die aktuelle Session mit library(fasterize). In einem ersten Schritt müssen wir eine Raster-Vorlage erstellen, welche dazu dient, die räumliche Ausdehnung und die Auflösung (Zellengrösse) des resultierenden Datensatzes festzulegen. library(fasterize) raster_template &lt;- raster(extent(skelettgehalt), resolution = 1000) Danach wird mit fasterize der Polygon-Datensatz in ein Raster konvertiert. Mit field = kann festgelegt werden, aus welcher Spalte die Werte des Output Datensatzes entnommen werden sollten. GIS-Experten werden sich erinnern, dass im Gegensatz zu Flächen in einem Vektordatensatz, welche viele verschiedene Attributen haben können, ein Raster nur noch ein Attribut (hier SKELETT). skelett_raster &lt;- fasterize(skelettgehalt,raster_template,field = &quot;SKELETT&quot;) ggplot() + geom_stars(data = st_as_stars(skelett_raster)) + coord_equal() 2.1.8.3 Teilaufgabe C: Rasterwerte extrahieren Mit raster::extract() könnnen nun die Rasterwerte aus dem Rasterdatensatz extrahiert werden. In fun = kann festgelegt werden, ob und mit welcher Funktion die vielen Rasterzellen pro Polygon aggregiert werden sollen. Wir möchten nur den häufigsten Wert zurück erhalten, sprich den Modus dafür gibt es in R leider keine eingebaute Funktion, weshalb wir unsere eigene basteln müssen: mode &lt;- function(x,na.rm = FALSE) { ux &lt;- unique(x) ux[which.max(tabulate(match(x, ux)))] } Nun können wir mit raster::extract() den Modus in jedem Puffer berechnen. wasser_skelett$skelett_mode &lt;- extract(skelett_raster,wasser_2km,fun = mode)[,1] Jetzt könnnen wir prüfen, wie oft die beiden Join-Varianten übereinstimmen. Erstelle dazu einen Facet-Plot, indem für jede Skelett-Kategorie die Modus-Kategorie (sprich die häufigste Kategorie) im den Punkt umgebenden Puffer darstellt. 2.1.9 Aufgabe 7: Spatial Join mit Kantone, Bezirke, Gemeinden Zum Abschluss der Übung wenden wir uns nun noch der Aggregationsabhängigkeit von Geodaten zu. Dazu wollen wir die Daten zur Wasserverfügbarkeit auf verschiedenen Massstäben aggregieren. Als Aggregationseinheiten verwenden wir die politische Gliederung der Schweit - Kantone, Bezirke und Gemeinden. Die Frage stellt sich, ob die Daten ev. das MAUP illustrieren. Hier könnten wir wir nochmals st_join() verwenden, aber da wir diesmal Polygone im Fokus haben (Bezirke, Kantone) und mehrere Punkte in einem Polygon vorkommen können, ist dieser Weg etwas umständlich. Wir nutzen deshalb die Funktion aggregate(), und spezifizieren x = wasser, by = kantone und FUN = mean. Hinweis: Das Beschriften der Kantone ist fakultativ und nicht ganz trivial. 2.1.10 Aufgabe 8 (für Ambitionierte) Politische Grenzen sind für die meisten natürlichen Phänomene irrelevant. Wir könnten deshalb auch eine regelmässige Kachelung (sog. Tesselierung) des Untersuchungsgebietes vornehmen. Dafür könnten wir mit st_make_grid() eine Kachelung für das gewählte Untersuchungsgebiet (x =) in einer bestimmten Grösse (cellsize =) als Quadrate (square = TRUE) oder sogar mit hübschen Hexagonen (square = FALSE) durchführen. Probier’s aus! Eine weitere, zusätzliche (und sehr anspruchsvolle) Herausforderung ist das Zeichnen und Beschriften der Kantosgrenzen. Hierzu geben wir für Wagemutige gerne Tips. "]
]
