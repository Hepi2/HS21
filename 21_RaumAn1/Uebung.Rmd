```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,include = TRUE,message = FALSE, collapse=TRUE) 
```


## Übung


### Vorbereitung

Es gibt bereits eine Vielzahl von Libraries um in R mit räumlichen Daten zu arbeiten, die ihrerseits wiederum auf weiteren Libraries basieren (Stichwort `dependencies`). 

- Für *Vektordaten* dominierte lange das Package `sp`, welches nun aber schrittweise durch `sf` abgelöst wird. Wir werden wenn immer möglich mit `sf` arbeiten und nur in Ausnahmefällen auf andere Libraries zurück greifen.
- Für *Rasterdaten* exisitert das Packages `raster`

Für die Integration von Vektor und Rasterdaten existiert die Library `starts`: *S*patio*t*emporal *A*rrays for *R*aster and *V*ector Datacubes. Diese Tools sind teilweise sehr gut dem Tidyverse-Workflow (`group_by`, `mutate`, `summarise`, `%>%`) integriert. Lade zu beginn die folgenden notwenigen Libraries (installiere die fehlenden Packages mit `install.package("packagename")`).
 
```{r warning=FALSE, echo = TRUE}
library(sf)
library(tidyverse)
library(stars)
library(raster)
```


### Aufgabe 1: Daten runterladen und importieren

Lade zunächst die Datensätze unter folgenden Links herunter und importiere sie mit dem Befehl `read_sf()` in R:

- [bodeneignung_skelett.gpkg](21_RaumAn1/data/skelettgehalt_proben.gpkg) Datensatz abgeleitt des Bundesamt für Landwirtschaft ([weitere Informationen](https://www.blw.admin.ch/blw/de/home/politik/datenmanagement/geografisches-informationssystem-gis/download-geodaten.html))
- [kantone.gpkg](21_RaumAn1/data/kantone.gpkg): Ein Datensatz der Swisstopo ([weitere Informationen](https://shop.swisstopo.admin.ch/de/products/landscape/boundaries3D))
- [bezirke.gpkg](21_RaumAn1/data/bezirke.gpkg) Ein Datensatz der Swisstopo ([weitere Informationen](https://shop.swisstopo.admin.ch/de/products/landscape/boundaries3D))
- [wasserverfuegbarkeit_boden.gpkg](21_RaumAn1/data/wasserverfuegbarkeit_boden.gpkg): Ein Datensatz der WSL ([weiteren Informationen](https://www.wsl.ch/de/ueber-die-wsl/programme-und-initiativen/abgeschlossene-programme-und-grossprojekte/wuk.html))
  
Es handelt sich um Geodatensätze im Format Geopackage ("\*.gpkg"). Dieses Format stellt eine Alternative zum bekannteren Format "Shapefiles" dar und ist etwas leichter zu behandeln, da es nicht komprimiert (d.h. gezipped) werden muss. 

```{r, echo = TRUE}

wasser <- read_sf("21_RaumAn1/data/wasserverfuegbarkeit_boden.gpkg")

kantone <- read_sf("21_RaumAn1/data/kantone.gpkg")
bezirke <- read_sf("21_RaumAn1/data/bezirke.gpkg") 
gemeinden <- read_sf("21_RaumAn1/data/gemeinden.gpkg")
skelettgehalt <- read_sf("21_RaumAn1/data/bodeneignung_skelett.gpkg")

```


Schau Dir die importierten Datensätze an, nutzt dafür `View()`, `str()`, `class()`. Studiere ausserdem die weiteren Informationen zu den Datensätzen.


### Aufgabe 2: Daten Visualisieren

Wir hatten anfangs erwähnt, dass Geodaten mit `sf` und `raster` sich teilweise sehr schön in die bekannten Tidyverse workflows integrieren lassen. Das merkt man schnell, wenn man die Daten visualisieren möchte. In InfoVis 1 & 2 haben wir intensiv mit `ggplot2` gearbeitet und dort die Layers `geom_point()` und `geom_line()` kennen gelernt. Zusätzlich beinhaltet `ggplot` die Möglichkeit, mit `geom_sf()` Vektordaten direkt und sehr einfach zu plotten. Führe die angegebenen R-Befehle aus und studiere die entstehenden Plots. Welche Unterschiede findest Du? Wie erklärst Du diese Unterschiede?

```{r echo = TRUE}
ggplot(bezirke) + 
  geom_sf() +
  labs(caption = "X/Y-Kooridnaten liegen im Bereich 2'600'000 (x-Achse) bzw. 1'300'000 (y-Achse)")
```

```{r echo = TRUE}
ggplot(wasser) + 
  geom_sf() +
  labs(caption = "X/Y-Koordinaten liegen im Bereich 6 - 11 (x-Achse), respektive 46-47 (y-Achse)")
```




### Aufgabe 3 Koordinatensysteme *zuweisen*

In den obigen beiden obigen sehr einfachen Kartogrammen fallen verschiedene Dinge auf: 

- die X/Y Achsen weisen zwei ganz unterschiedlichen Zahlenbereiche auf, und
- der Umriss der Schweiz scheint in der zweiten Grafik "gestaucht" zu sein.

Dies hat natürlich damit zu tun, dass die beiden Datensätze in unterschiedlichen Koordinatensystemen erfasst wurden. Koordinatensysteme werden mit CRS (*C*oordinate *R*eference *S*ystem) abgekürzt. Mit `st_crs()` könnnen normalerweise die zugewiesenen Koordinatensysteme abgefragt werden.

```{r, echo = TRUE}
st_crs(wasser)
st_crs(bezirke)
```

Leider sind in unserem Fall keine Koordinatensysteme zugewiesen. Mit etwas Erfahrung kann man das Koordinatensystem aber erraten, so viele kommen nämlich gar nicht in Frage. Am häufigsten trifft man hierzulande bei Geodatensätzen eines der drei folgenden Koordinatensysteme an:

- [CH1903 LV03](https://epsg.io/21781): das alte Koordinatenystem der Schweiz
- [CH1903+ LV95](https://epsg.io/2056): das neue Koordinatensystem der Schweiz
- [WGS84](https://epsg.io/4326): ein häufig genutztes weltumspannendes Koordinatensystem

Nun gilt es, anhand der Koordinaten die in der Spalte `geometry` ersichtlich sind das korrekte Koordinatensystem zu erraten. Wenn man sich auf [epsg.io/map](https://epsg.io/map#srs=4326&x=8.407288&y=46.773731&z=9&layer=streets) die Schweiz anschaut, kann man die Koordinaten in verschiedenen Koordinatensystem betrachten. 

![Koordinanten (des Fadenkreuzes) werden im ausgewählten Koordinatensystem dargestellt](koordinatenpaar.jpg)

![Das Koordinatensystem, in welchem die Koordinaten dargestellt werden sollen, kann mit "Change" angepasst werden](koordinatensystem.jpg)

![Für Enthusiasten: Schau Dir die Schweiz in verschiedenen Koordinatensystemen an, in dem Du auf "Reproject Map" klickst](reproject.jpg)


Wenn man diese Koordinaten mit den unserer Datensätze vergleicht, dann ist schnell klar, dass es sich beim Datensatz `wasser` um das Koordinatensystem WGS84 handelt und bei `bezirke` das Koordinatensystem CH1903+ LV95. Diese Koordinatensyteme weisen wir nun mit `st_set_crs()` und dem entsprechenden *EPSG*-Code (siehe die jeweiligen Links) zu.

```{r, echo = TRUE}
wasser <- st_set_crs(wasser, 4326)
bezirke <- st_set_crs(bezirke, 2056)

st_crs(wasser)
```

Weise auch für die anderen Datensätze (`kantone`, `gemeinden`, `skelettgehalt`) das *korrekte* Koordinatensytem zu.


```{r}
kantone <- st_set_crs(kantone, 2056)
gemeinden <- st_set_crs(gemeinden, 2056)
skelettgehalt <- st_set_crs(skelettgehalt, 2056)
```

Jetzt wo das CRS der Datensätze bekannt ist, können diese in einem gemeinsamen Plot visualisiert werden, `ggplot` kümmert sich darum die unterschiedlichen Koordinatensysteme zu vereinheitlichen. Probier das aus, indem du `kantone` und `wasser` in einem `ggplot` kombinierst.

Die Achsen werden dann immer in WGS84 beschriftet. Wenn das stört, kann man `coord_sf(datum = 2056)` in einem weiteren Layer spezifizieren. Oder aber man blendet die Achsenbeschriftung mit `theme_void()` komplett aus. Versuche beide Varianten.

```{r}
ggplot() + 
  geom_sf(data = kantone) +
  geom_sf(data = wasser)
```




### Aufgabe 4: Koordinatensyteme *transformieren*

In der vorherigen Übung haben wir das bestehende Kooridnatensystem *zugewiesen*. Dabei haben wir die bestehenden Koordinaten (in der Spalte `geom`) *nicht* manipuliert. Ganz anders ist eine *Transformation* der Daten von einem Koordinatensystem in das andere. Bei einer Transformation werden die Koordinaten in das neue Koordinatensystem umgerechnet und somit manipuliert. Aus praktischen Gründen wollen <!-- Was sind diese Gründe? genauer erläutern? -->
wir all unsere Daten ins neue Schweizer Koordinatensystem CH1903+ LV95 transfomieren. Transformiere den Datensatz `wasser` mit `st_transform()`in CH1903+ LV95, nutze dafür den korrgekten EPSG-Code.

Vor der Transformation (betrachte die Spalte `geom` sowie die Attribute `epsg (SRID)` und `proj4string`): 

```{r, echo = TRUE}
wasser
```


```{r}
wasser <- st_transform(wasser, 2056)
```


Nach der Transformation (betrachte die Spalte `geom`):

```{r, echo = TRUE}
wasser
```


### Aufgabe 5: 

Wir wollen nun wissen, ob die Wasserverfügbarkeit im Boden vom Skelettgehalt abhängig ist. Dazu nutzen wir die GIS-Technik *Spatial Join*, die in der Vorlesung beschrieben wurde. In `sf` können wir Spatial Joins mit der Funktion `st_join` durchführen, dabei gibt es nur `left` sowie `inner`-Joins. So müssen die Punkte "Links", also an erste Stelle aufgeführt werden, da wir ja Attribute *an* die Punkte anheften wollen.

```{r, echo = TRUE}
wasser_skelett <- st_join(wasser,skelettgehalt)
wasser_skelett

```

Führe den obigen Spatial Join aus und erstelle anschliessend einen Boxplot pro Skelett. Für `ggplot` boxplots ist es sinnvoll, denn Skelettgehalt vorgängig von `numeric` in `factor` zu konverieren.

```{r}

wasser_skelett %>%
  mutate(SKELETT = factor(SKELETT)) %>%
  ggplot() +  
  geom_boxplot(aes(SKELETT,wasserverfuegbarkeit))
```



### Aufgabe 6: Spatial Join mit Flächen


In der letzten aufgabe haben wir für jede Probe aus `wasser` den Skelettgehalt des darunterliegenden Polygons ermittelt. Für Proben, die gerade an der Grenze zu einem Polygon mit einem anderen Skelettgehalt liegen ist dieser Wert aber nicht sehr aussagekräftig. Da wäre es wichtiger zu wissen, wie hoch der *mittlere* oder *mediane* Skelettgehalt in einem bestimmten Umkreis (z.B. 2 km) um die Probe ist. In den kommenden Teilaufgaben lösen wir diese Herausforderung.

#### Teilaufgabe A: Punkte mit Puffer versehen

Dafür müssen wir die Punkte mit einem Buffer versehen, dies erreichen wir mit `st_buffer()`. Erstelle einen Datensatz `wasser_2km` wo jeder Punkt um 2'000 m gepuffert wurde. Visualisiere diesen Datensatz. Beachte, dass es sich nun nicht mehr um Punkte, sondern um Flächen handelt (`POLYGON`)

```{r}
wasser_2km <- st_buffer(wasser,2000)
```

```{r, echo = TRUE}
ggplot(wasser_2km) + geom_sf(fill = "blue")
```



#### Teilaufgabe B: Polygon in Raster konvertieren

Um Flächen miteinander zu Verrechnen ("Was ist der mittlere Skelettgehalt im Umkreis von 2km?") ist es einfnacher, wenn der Skelettgehalt-Datensatz aus einem Raster-Datenstz besteht. Hierzu brauchen wir die Funktion `fasterize()` aus der gleichnamigen Library. Installiere diese Library (wenn nötig) und importiere sie in die aktuelle Session mit `library(fasterize)`.

In einem ersten Schritt müssen wir eine Raster-Vorlage erstellen welche dazu dient, die räumliche Ausdehnung und die auflösung (Zellengrösse) des resultierenden Datensatzes festzulegen. 


```{r, echo = TRUE}
library(fasterize)

raster_template <- raster(extent(skelettgehalt), resolution = 1000)
```

Danach wird mit `fasterize` das Polygon in ein Raster konvertiert. Mit `field = ` kann festgelegt werden, aus welcher Spalte die Werte des Output Datensatzes entnommen werden sollten.

```{r, echo = TRUE}
skelett_raster <- fasterize(skelettgehalt,raster_template,field = "SKELETT")

ggplot() + geom_stars(data = st_as_stars(skelett_raster))

```

#### Teilaufgabe B: Rasterwerte extrahieren

Mit `raster::extract()` könnnen nun die Rasterwerte aus dem Rasterdatensatz extrahiert werden. In `fun = ` kann festgelegt werden, ob und mit welcher Funktion die vielen Rasterzellen pro Polygon aggregiert werden sollen. Wir möchten nur den häufigsten Wert zurück erhalten, sprich den [Modus](https://de.wikipedia.org/wiki/Modus_(Statistik)) dafür gibt es in `R` leider keine eingebaute Funktion, weshalb wir unsere eigene basteln müssen:

```{r}
mode <- function(x,na.rm = FALSE) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}
```

Nun können wir mit `raster::extract()` den Modus in jedem Polygon berechnen.

```{r, echo = TRUE}


wasser_skelett$skelett_mode <- extract(skelett_raster,wasser_2km,fun = mode)[,1]


```

Nun könnnen wir Prüfen, wie oft die beiden Join-Varianten übereinstimmen:

```{r}
ggplot(wasser_skelett) + geom_bar(aes(skelett_mode)) + facet_wrap(~SKELETT)

```


### Aufgabe 7: Spatial Join mit Kantone, Bezirke, Gemeinden

Nun wollen wir für verschiedenen politischen Einheiten (Kantonen, Bezirke, Gemeinde) die Wasserverfügbarkeit aggregieren. Dafür gehen wir wie folgt vor:

1. Pro Punkt ermitteln, in welcher Gemeinde er liegt (`st_join()`)
2. Resultierenden Datensatz (aus 1.) in eine `data.frame` konvertieren und nach Gemeinde gruppieren (`group_by()`)
3. Gruppierter Datensatz (aus 2.) verwenden um mittelwert der Wasserverfügbarkeit aller Punkte *pro Gemeinde* ermitteln (`summarise()`)
4. Resultierender Datensatz (aus 3.) mit Gemeinde verbinden (`left_join()`)
5. Resultat (aus 4.) visualisieren.

Tip für Schrit 2: Um zu Prüfen, ob sich eine Spalte für `group_by()` eignet (sie sollte ja pro Geometrie eindeutig sein), kannst du `anyDuplicated()` *vor* dem "Join" verwenden.

- 

```{r}

anyDuplicated(kantone$OBJECTID)

st_join(wasser,kantone) %>%
  st_set_geometry(NULL) %>%
  group_by(OBJECTID) %>%
  summarise(wasserverfuegbarkeit = mean(wasserverfuegbarkeit, na.rm = TRUE)) %>%
  left_join(kantone, ., by = "OBJECTID") %>%
  ggplot() + 
  geom_sf(aes(fill = wasserverfuegbarkeit)) + 
  geom_sf(data = wasser,size = 0.1) +  
  labs(title = "Mittlere Wasserverfügbarkeit im Boden", subtitle = "pro Kanton", fill = "") +
  theme_void() +
  theme(legend.position = "bottom",legend.direction = "horizontal") 


st_join(wasser,bezirke) %>%
  st_set_geometry(NULL) %>%
  group_by(OBJECTID) %>%
  summarise(wasserverfuegbarkeit = mean(wasserverfuegbarkeit, na.rm = TRUE)) %>%
  left_join(bezirke, ., by = "OBJECTID") %>%
  ggplot() + 
  geom_sf(aes(fill = wasserverfuegbarkeit)) + 
  geom_sf(data = wasser,size = 0.1) +
  labs(title = "Mittlere Wasserverfügbarkeit im Boden", subtitle = "pro Gemeinde", fill = "") +
  theme_void() +
  theme(legend.position = "bottom",legend.direction = "horizontal") 



st_join(wasser,gemeinden) %>%
  st_set_geometry(NULL) %>%
  group_by(OBJECTID) %>%
  summarise(wasserverfuegbarkeit = mean(wasserverfuegbarkeit, na.rm = TRUE)) %>%
  left_join(gemeinden, ., by = "OBJECTID") %>%
  ggplot() + 
  geom_sf(aes(fill = wasserverfuegbarkeit)) + 
  geom_sf(data = wasser,size = 0.1) +
  labs(title = "Mittlere Wasserverfügbarkeit im Boden", subtitle = "pro Gemeinde", fill = "") +
  theme_void() +
  theme(legend.position = "bottom",legend.direction = "horizontal") 

```



### Aufgabe 8 (für Ambitionierte)

Politische Grenzen sind für die meisten natürlichen Phänomene irrelevant. Man kan deshalb auch eine regelmässige Kachelung des Untersuchungsgebietes vornehmen. Daür kann man mit `st_make_grid()` ein Kachelung für das Gewählte Untersuchungsgebiet (`x = `) in einer bestimmten Grösse (`cellsize = `)  als Quadrate (`square = TRUE`) oder Hexagons (`square = FALSE`) durchführen. 


```{r}
hex <- st_make_grid(kantone,cellsize = 20000, square = FALSE) %>%
  st_sf() %>%
  mutate(id = row_number()) %>%
  st_join(wasser) %>%
  group_by(id) %>%
  summarise(wasserverfuegbarkeit = mean(wasserverfuegbarkeit,na.rm = TRUE)) %>%
  st_intersection(st_union(kantone))

ggplot() +
  geom_sf(data = hex, aes(fill = wasserverfuegbarkeit), colour = "grey") +
  labs(title = "Mittlere Wasserverfügbarkeit im Boden", subtitle = "20km Hexagon", fill = "") +
  theme_void() +
  theme(legend.position = "bottom",legend.direction = "horizontal") 


```



