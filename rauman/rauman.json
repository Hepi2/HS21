[
  {
    "path": "rauman/RaumAn1_Uebung_A/",
    "title": "Übungen A",
    "description": {},
    "author": [
      {
        "name": "Patrick Laube",
        "url": {}
      },
      {
        "name": "Nils Ratnaweera",
        "url": {}
      },
      {
        "name": "Nikolaos Bakogiannis",
        "url": {}
      }
    ],
    "date": "2021-10-26",
    "categories": [
      "RaumAn1"
    ],
    "contents": "\n\nContents\nAufgabe 1: Vektor Daten runterladen und importieren\nAufgabe 2: Daten Visualisieren\n\nEs gibt bereits eine Vielzahl von Packages um in R mit räumlichen Daten zu arbeiten, die ihrerseits wiederum auf weiteren Packages basieren (Stichwort dependencies).\nFür Vektordaten dominierte lange das Package sp, welches nun durch sf abgelöst wurde. Wir werden wenn immer möglich mit sf arbeiten und nur in Ausnahmefällen auf andere Packages zurück greifen.\nFür Rasterdaten dominierte lange das Packge raster, welches aber nur Schrittweise durch terra abgelöst wird. Wir werden wenn immer möglich mit terra arbeiten und nur in Ausnahmefällen auf terra zurück greifen.\n\n\nlibrary(sf)\nlibrary(dplyr)\nlibrary(terra)\nlibrary(ggplot2)\n\n\n\nAufgabe 1: Vektor Daten runterladen und importieren\nLade zunächst die Datensätze unter folgenden Links herunter:\n\nkantone.gpkg (Quelle: Swisstopo)\nbezirke.gpkg (Quelle: Swisstopo)\n\nEs handelt sich um Geodatensätze im Format Geopackage (“*.gpkg”), eine alternatives Datenformat zum bekannteren Format “Shapefiles”. Importiere die Datensätze wie folgt:\n\n\nkantone <- read_sf(\"kantone.gpkg\")\nbezirke <- read_sf(\"bezirke.gpkg\") \n\n\n\nSchau Dir die importierten Datensätze an. Am meisten Informationen zu sf Objekten bekommst du, wenn du dir den Datensatz in der Konsole anschaust (in dem du den Variabel-Name in der Konsole eintippst). Mit dem RStudio Viewer werden sf Objekte nur sehr langsam geladen und die Metadaten werden nicht angezeigt.\nAufgabe 2: Daten Visualisieren\nVektordaten (sf Objekte) lassen sich teilweise sehr schön in die bekannten Tidyverse workflows integrieren. Das merkt man schnell, wenn man die Daten visualisieren möchte. In InfoVis 1 & 2 haben wir intensiv mit ggplot2 gearbeitet und dort die Layers geom_point() und geom_line() kennen gelernt. Zusätzlich beinhaltet ggplot die Möglichkeit, mit geom_sf() Vektordaten direkt und sehr einfach zu plotten. Führe die angegebenen R-Befehle aus und studiere die entstehenden Plots. Welche Unterschiede findest Du? Wie erklärst Du diese Unterschiede?\n\n\nggplot(bezirke) + \n  geom_sf()\n\n\n\n\n\n\nggplot(kantone) + \n  geom_sf()\n\n\n\n\n\n\n\n",
    "preview": "rauman/RaumAn1_Uebung_A/distill-preview.png",
    "last_modified": "2021-11-18T18:15:31+00:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "rauman/RaumAn2_Uebung_A/",
    "title": "Übungen A",
    "description": "Analyse von Punktverteilungen",
    "author": [
      {
        "name": "Patrick Laube",
        "url": {}
      },
      {
        "name": "Nils Ratnaweera",
        "url": {}
      },
      {
        "name": "Nikolaos Bakogiannis",
        "url": {}
      }
    ],
    "date": "2021-11-01",
    "categories": [
      "RaumAn2"
    ],
    "contents": "\n\n\n\nlibrary(gstat)\nlibrary(sf)\nlibrary(tidyverse)\nlibrary(lubridate)\nlibrary(stars)\n\nluftqualitaet <- read_sf(\"luftqualitaet.gpkg\")\nkantone <- read_sf(\"kantone.gpkg\")\nrotmilan <- read_sf(\"rotmilan.gpkg\")\n\n\nluftqualitaet <- st_set_crs(luftqualitaet,2056)\nkantone <- st_set_crs(kantone, 2056)\nrotmilan <- st_set_crs(rotmilan, 2056)\n\n\n\nAls erstes berechnen wir die G-Function für die Rotmilanpositionen wie auch für die Luftqualitätsmessungen NO2:\nSchritt 1: Da es sich beim Rotmilan um relativ viele Datenpunkte handelt, nehmen wir mit st_sample() ein subset aus dem Datensatz. Dies verkürzt die Rechenzeit substantiell und verändert die Resultate kaum.\n\n\nrotmilan_sample <- sample_n(rotmilan,1000)\n\n\n\nSchritt 2: Mit st_distance() können Distanzen zwischen zwei sf Datensätze berechnet werden. Wird nur ein Datensatz angegeben, wird eine Kreuzmatrix erstellt wo die Distanzen zwischen allen Features zu allen anderen Features dargestellt werden. Wir nützen diese Funktion zur Berechnung der nächsten Nachbarn.\n\n\nrotmilan_distanzmatrix <- st_distance(rotmilan_sample)\n\n# zeige die ersten 6 Zeilen und Spalten der Matrix\n# jeder Distanz wurde 2x Gemessen (vergleiche Wert [2,1] mit [1,2])\n# die Diagonale ist die Distanz zu sich selber (gleich 0)\nrotmilan_distanzmatrix[1:6,1:6] \n\n\nUnits: [m]\n          [,1]      [,2]      [,3]     [,4]     [,5]     [,6]\n[1,]     0.000  2658.185  2378.256 53372.30 35776.05 14058.65\n[2,]  2658.185     0.000  3730.182 55806.69 33118.53 15130.58\n[3,]  2378.256  3730.182     0.000 52236.46 36128.59 11759.22\n[4,] 53372.297 55806.694 52236.457     0.00 87427.52 44942.18\n[5,] 35776.049 33118.531 36128.588 87427.52     0.00 42708.51\n[6,] 14058.647 15130.580 11759.216 44942.18 42708.51     0.00\n\nSchritt 3: Nun wollen wir wissen, wie gross die kürzeste Distanz von jedem Punkt zu seinem nächsten Nachbarn beträgt, also die kürzeste Distanz pro Zeile. Zuerst aber müssen wir die diagonalen Werte noch entfernen, denn diese stellen ja jeweils die Distanz zu sich selber dar und sind immer 0. Danach kann mit apply() eine Funktion (FUN = min) über die Zeilen (MARGIN = 1) einer Matrix (X = rotmilan_distanzmatrix) gerechnet werden. Zusätzlich müssen wir noch na.rm = TRUE setzen, damit NA Werte von der Berechnung ausgeschlossen werden. Das Resultat ist ein Vektor mit gleich vielen Werten wie Zeilen in der Matrix.\n\n\ndiag(rotmilan_distanzmatrix) <- NA # entfernt alle diagonalen Werte\n\nrotmilan_mindist <- apply(rotmilan_distanzmatrix,1,min, na.rm = TRUE)\n\n\n\nNun wollen wir die kumulierte Häufigkeit der Werte in einer Verteilungsfunktion (engl: Empirical Cumulative Distribution Function, ECDF) darstellen. Dafür müssen wir den Vektor zuerst noch in einen Dataframe packen, damit ggplot damit klar kommt:\n\n\nrotmilan_mindist_df <- data.frame(distanzen = rotmilan_mindist)\n\nggplot() + geom_step(data = rotmilan_mindist_df, aes(distanzen),stat = \"ecdf\")\n\n\n\n\nFühre nun die gleichen Schritte mit luftqualitaet durch und vergleiche die ECDF-Plots. Hinweis: st_sample() ist bei luftqualitaet nicht nötig, da es sich hier um einen kleineren Datensatz handelt.\n\n\nluftqualitaet_distanzmatrix <- st_distance(luftqualitaet)\n\ndiag(luftqualitaet_distanzmatrix) <- NA\n\nluftqualitaet_mindist <- apply(luftqualitaet_distanzmatrix,1,min,na.rm = TRUE)\n\nluftqualitaet_mindist_df <- data.frame(distanzen = luftqualitaet_mindist, data = \"Luftqualität\")\n\nrotmilan_mindist_df$data <- \"Rotmilan\"\n\nmindist_df <- rbind(luftqualitaet_mindist_df,rotmilan_mindist_df)\n\nggplot() + \n  geom_step(data = mindist_df, aes(distanzen, colour = data),stat = \"ecdf\") +\n  labs(colour = \"Datensatz\")\n\n\n\n\n\n\n\n",
    "preview": "rauman/RaumAn2_Uebung_A/distill-preview.png",
    "last_modified": "2021-11-18T18:15:31+00:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  }
]
