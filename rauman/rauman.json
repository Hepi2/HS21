[
  {
    "path": "rauman/RaumAn1_Uebung_A/",
    "title": "Übungen A: Einführung",
    "description": {},
    "author": [
      {
        "name": "Patrick Laube",
        "url": {}
      },
      {
        "name": "Nils Ratnaweera",
        "url": {}
      },
      {
        "name": "Nikolaos Bakogiannis",
        "url": {}
      }
    ],
    "date": "2021-11-29",
    "categories": [
      "RaumAn1"
    ],
    "contents": "\n\nContents\nAufgabe 1: Vektor Daten runterladen und importieren\nAufgabe 2: Daten Visualisieren\nInput: Koodinatensysteme\nAufgabe 3: Koordinatensyteme transformieren\nAufgabe 4: Chloroplethen Karte\n\nEs gibt bereits eine Vielzahl von Packages um in R mit räumlichen Daten zu arbeiten, die ihrerseits wiederum auf weiteren Packages basieren (Stichwort dependencies). Für Vektordaten dominierte lange das Package sp, welches nun durch sf abgelöst wurde. Wir werden wenn immer möglich mit sf arbeiten und nur in Ausnahmefällen auf andere Packages zurück greifen.\nFür die kommenden Übungen könnt ihr folgende Packages installieren bzw. laden:\n\n\nlibrary(sf)\nlibrary(dplyr)\nlibrary(ggplot2)\n\n\n\nAufgabe 1: Vektor Daten runterladen und importieren\nLade zunächst die Datensätze unter folgenden Links herunter:\n\nkantone.gpkg (Quelle: Swisstopo)\ngemeinden.gpkg (Quelle: Swisstopo)\n\nEs handelt sich um Geodatensätze im Format Geopackage (“*.gpkg”), eine alternatives Datenformat zum bekannteren Format “Shapefiles”. Importiere die Datensätze wie folgt:\n\n\nkantone <- read_sf(\"kantone.gpkg\")\ngemeinden <- read_sf(\"gemeinden.gpkg\") \n\n\n\nSchau Dir die importierten Datensätze an. Am meisten Informationen zu sf Objekten bekommst du, wenn du dir den Datensatz in der Konsole anschaust (in dem du den Variabel-Name in der Konsole eintippst). Mit dem RStudio Viewer werden sf Objekte nur sehr langsam geladen und die Metadaten werden nicht angezeigt.\nAufgabe 2: Daten Visualisieren\nVektordaten (sf Objekte) lassen sich teilweise sehr schön in die bekannten Tidyverse workflows integrieren. Das merkt man schnell, wenn man die Daten visualisieren möchte. In InfoVis 1 & 2 haben wir intensiv mit ggplot2 gearbeitet und dort die Layers geom_point() und geom_line() kennen gelernt. Zusätzlich beinhaltet ggplot die Möglichkeit, mit geom_sf() Vektordaten direkt und sehr einfach zu plotten. Führe die angegebenen R-Befehle aus und studiere die entstehenden Plots. Welche Unterschiede findest Du? Wie erklärst Du diese Unterschiede?\n\n\nggplot(gemeinden) + \n  geom_sf()\n\n\n\nggplot(kantone) + \n  geom_sf()\n\n\n\n\nInput: Koodinatensysteme\nIn der obigen visualierung fällt folgendes auf:\ndie X/Y Achsen weisen zwei ganz unterschiedlichen Zahlenbereiche auf (vergleiche die Achsenbeschriftungen)\nder Umriss der Schweiz sieht in den beiden Datensätzen unterschiedlich aus (kantone ist gegenüber gemeinden gestaucht)\nDies hat natürlich damit zu tun, dass die beiden Datensätze in unterschiedlichen Koordinatensystemen erfasst wurden. Koordinatensysteme werden mit CRS (Coordinate Reference System) abgekürzt. Mit st_crs() könnnen die zugewiesenen Koordinatensysteme abgefragt werden.\n\n\nst_crs(kantone)\n\n\nCoordinate Reference System: NA\n\nst_crs(gemeinden)\n\n\nCoordinate Reference System: NA\n\nLeider sind in unserem Fall keine Koordinatensysteme zugewiesen. Mit etwas Erfahrung kann man das Koordinatensystem aber erraten, so viele kommen nämlich gar nicht in Frage. Am häufigsten trifft man hierzulande eines der drei folgenden Koordinatensysteme an:\nCH1903 LV03: das alte Koordinatensystem der Schweiz\nCH1903+ LV95: das neue Koordinatensystem der Schweiz\nWGS84: ein häufig genutztes weltumspannendes geodätisches Koordinatensystem, sprich die Koordinaten werden in Länge und Breite angegeben (Lat/Lon).\nNun gilt es, anhand der Koordinaten die in der Spalte geometry ersichtlich sind das korrekte Koordinatensystem festzustellen. Wenn man sich auf epsg.io/map die Schweiz anschaut, kann man die Koordinaten in verschiedenen Koordinatensystem betrachten.\nBedienungshinweise:\n\nKoordinanten (des Fadenkreuzes) werden im ausgewählten Koordinatensystem dargestellt\n\nDas Koordinatensystem, in welchem die Koordinaten dargestellt werden sollen, kann mit “Change” angepasst werden\n\nFür Enthusiasten: Schau Dir die Schweiz in verschiedenen Koordinatensystemen an, in dem Du auf “Reproject Map” klickst\n\nWenn man diese Koordinaten mit den Koordinaten unserer Datensätze vergleicht, dann ist schnell klar, dass es sich beim Datensatz kantone um das Koordinatensystem WGS84 handelt und bei gemeinden das Koordinatensystem CH1903+ LV95. Diese Koordinatensyteme weisen wir nun mit st_set_crs() und dem entsprechenden EPSG-Code (siehe die jeweiligen Links) zu.\n\n\nkantone <- st_set_crs(kantone, 4326)\ngemeinden <- st_set_crs(gemeinden, 2056)\n\n# zuweisen mit st_set_crs(), abfragen mit st_crs()\nst_crs(kantone)\n\n\nCoordinate Reference System:\n  User input: EPSG:4326 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    USAGE[\n        SCOPE[\"Horizontal component of 3D system.\"],\n        AREA[\"World.\"],\n        BBOX[-90,-180,90,180]],\n    ID[\"EPSG\",4326]]\n\nAuch wenn das CRS der Datensätze bekannt ist, nutzt ggplot immer noch EPSG 4326 um die Achsen zu beschriften. Wenn das stört, kann man coord_sf(datum = 2056) in einem weiteren Layer spezifizieren. Oder aber man blendet die Achsenbeschriftung mit theme_void() komplett aus. Versuche beide Varianten.\n\n\n\nAufgabe 3: Koordinatensyteme transformieren\nIn der vorherigen Übung haben wir das bestehende Koordinatensystem zugewiesen. Dabei haben wir die bestehenden Koordinaten (in der Spalte geom) nicht manipuliert. Ganz anders ist eine Transformation der Daten von einem Koordinatensystem in das andere. Bei einer Transformation werden die Koordinaten in das neue Koordinatensystem umgerechnet und somit manipuliert. Aus praktischen Gründen wollen  wir all unsere Daten ins neue Schweizer Koordinatensystem CH1903+ LV95 transfomieren. Transformiere den Datensatz kantone mit st_transform()in CH1903+ LV95, nutze dafür den korrekten EPSG-Code.\nVor der Transformation (betrachte die Attribute Bounding box sowie Geodetic CRS):\n\n\nkantone\n\n\nSimple feature collection with 51 features and 6 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 5.955902 ymin: 45.81796 xmax: 10.49217 ymax: 47.80845\nGeodetic CRS:  WGS 84\n# A tibble: 51 × 7\n   NAME       KANTONSNUM SEE_FLAECH KANTONSFLA KT_TEIL EINWOHNERZ\n * <chr>           <dbl>      <dbl>      <dbl> <chr>        <dbl>\n 1 Graubünden         18         NA     710530 0           199021\n 2 Bern                2      11897     595951 1          1039474\n 3 Valais             23       1060     522463 0           345525\n 4 Vaud               22      39097     321202 1           805098\n 5 Ticino             21       7147     281215 0           351491\n 6 St. Gallen         17       7720     202820 1           510734\n 7 Zürich              1       6811     172894 0          1539275\n 8 Fribourg           10       7818     167142 1           321783\n 9 Luzern              3       6438     149352 0           413120\n10 Aargau             19        870     140380 1           685845\n# … with 41 more rows, and 1 more variable: geom <POLYGON [°]>\n\n\n\n\nNach der Transformation (betrachte die Attribute Bounding box sowie Projected CRS):\n\n\nkantone\n\n\nSimple feature collection with 51 features and 6 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2485410 ymin: 1075268 xmax: 2833858 ymax: 1295934\nProjected CRS: CH1903+ / LV95\n# A tibble: 51 × 7\n   NAME       KANTONSNUM SEE_FLAECH KANTONSFLA KT_TEIL EINWOHNERZ\n * <chr>           <dbl>      <dbl>      <dbl> <chr>        <dbl>\n 1 Graubünden         18         NA     710530 0           199021\n 2 Bern                2      11897     595951 1          1039474\n 3 Valais             23       1060     522463 0           345525\n 4 Vaud               22      39097     321202 1           805098\n 5 Ticino             21       7147     281215 0           351491\n 6 St. Gallen         17       7720     202820 1           510734\n 7 Zürich              1       6811     172894 0          1539275\n 8 Fribourg           10       7818     167142 1           321783\n 9 Luzern              3       6438     149352 0           413120\n10 Aargau             19        870     140380 1           685845\n# … with 41 more rows, and 1 more variable: geom <POLYGON [m]>\n\nAufgabe 4: Chloroplethen Karte\nNun wollen wir die Gemeinden respektive die Kantone nach ihrer Einwohnerzahl einfärben. Dafür verwenden wir wie gewohnt die Methode aes(fill = ...) von ggplot.\nTipps:\num die scientific notation (z.B. 3e+03) zu verhindern, könnt ihr den Befehl options(scipen = 999) ausführen\num die Darstellung der Gemeinde- (bzw. Kantons-) Grenzen zu verhindern, könnt ihr im entsprechenden Layer color = NA setzen\n\n\n\nFigure 1: Der Vergleich dieser beiden Darstellungen veranschaulicht die MAUP Problematik sehr deutlich\n\n\n\n\n\n\n",
    "preview": "rauman/RaumAn1_Uebung_A/distill-preview.png",
    "last_modified": "2021-11-29T07:04:10+00:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "rauman/RaumAn1_Uebung_B/",
    "title": "Übung B Spatial Joins",
    "description": {},
    "author": [
      {
        "name": "Patrick Laube",
        "url": {}
      },
      {
        "name": "Nils Ratnaweera",
        "url": {}
      },
      {
        "name": "Nikolaos Bakogiannis",
        "url": {}
      }
    ],
    "date": "2021-11-26",
    "categories": [
      "RaumAn1"
    ],
    "contents": "\n\nContents\nAufgabe 1: Geopackage “Layers”\nAufgabe 2: Datensätze erkunden\nAufgabe 3: Spatial Join mit Punkten\nAufgabe 4: Spaital Join mit Flächen\n\n\n\n\nFür die kommende Übung arbeiten wir mit nachstehendem Datensatz. Lade diesen Herunter und importiere ihn in R.\n\ngruental.gpkg\n\nZudem brauchen wir die folgenden libraries:\n\n\nlibrary(dplyr)\nlibrary(sf)\nlibrary(ggplot2)\n\n\n\nAufgabe 1: Geopackage “Layers”\nAllenfalls ist euch beim Importieren des Geopackage gruental.pgkg folgende Warnmeldung aufgefallen:\nWarning message:\nIn evalq((function (..., call. = TRUE, immediate. = FALSE, noBreaks. = FALSE,  :\n  automatically selected the first layer in a data source containing more than one.\nDiese Warnmeldung weist darauf hin, dass das Geopackage gruental.gpkg mehrere Layers (rep. Datensätze) enthält und nur der erste Layer importiert wurde. Bringe mit dem Befehl st_layers die Layer Namen in Erfahrung und nutze diese im Anschluss in st_read (als Argument layer =) um die layers einzeln zu importieren und in variablen zu speichern (zB in als Variable wiesen und baeume).\nAufgabe 2: Datensätze erkunden\nNimm dir etwas Zeit und erkunde die beiden Datensätze. Nutze dafür auch die Visualisierungsmöglichkeiten von ggplot (insbesondere geom_sf).\n\n\n\nFigure 1: Beispielsweise kannst du die Daten in dieser Weise visualisieren.\n\n\n\nAufgabe 3: Spatial Join mit Punkten\nWir wollen nun für jeden Baum wissen, ob er sich in einer Wiese befindet oder nicht. Dazu nutzen wir die GIS-Technik Spatial Join, die in der Vorlesung beschrieben wurde. In sf können wir Spatial Joins mit der Funktion st_join durchführen, dabei gibt es nur left sowie inner-Joins (vgl. PrePro 1 & 2). So müssen die Punkte “Links”, also an erste Stelle aufgeführt werden, da wir ja Attribute an die Punkte anheften wollen.\nBeachte, dass der Output eine neue Spalte flaechen_typ aufweist. Diese ist leer (NA) wenn sich der entsprechende Baum nicht in einer Wiese befindet. Wie viele Bäume befinden sich in einer Wiese, wie viele nicht?\n\n\n\nAufgabe 4: Spaital Join mit Flächen\nAnalog der Vorlesung wollen wir nun in Erfahrung bringen, wie hoch der Wiesen-Anteil im Umkreis von 20m um jeden Baum ist. Dazu sind folgende Schritte nötig:\nAls erster Schritt müssen wir jeden Baum mit einem 20m Puffer verstehen. Nutze dazu st_buffer um speichere den Output als baeume_20m. Schau dir baeume_20m nun genau an. Um welchen Geometrietyp handelt es sich dabei nun?\nBerechnen nun die Schnittmenge aus baeume_20m und wiesen mit der Funktion st_intersection und speichere den Output als baeume_wiesen. Exploriere nun baeume_wiesen, auch mit ggplot(). Was ist passiert? Überprüfe die Anzahl Zeilen pro Datensatz. Haben die sich verändert? Wenn ja, warum?\nBerechnen nun die Flächengrösse pro Geometrie mit der Funktion st_area(). Speichere den Output in einer neuen Spalte von baeume_wiesen (z.B. mit dem Namen wiesen_flaeche). Tipp: Konvertiere den Output aus st_area einen nummerischen Vektor mit as.numeric().\nBerechne nun aus wiesen_flaeche den wiesen_anteil. Tipp: 100% ist die Kreisfläche aus \\(r^2\\times \\pi\\), wobei in unserem Fall \\(r = 20\\) entspricht.\nUm die berechneten Werte in den Datensatz baeume zu überführen braucht es noch folgende Schritte:\nKonvertiere baeume_wiesen in eine data.frame mit st_drop_geometry und speichere diese als baeume_wiesen_df\nNutze die Spalte baum_id in baeume_wiesen_df um den berechneten wiesen_anteil in den Datenatz baeume zu überführen. Tipp: Nutze dafür einen left_join\nErsetze alle NA Werte in der Spalte wiesen_anteil mit 0.\n\n\n\n\n\n\nFigure 2: Nach dieser Übung kannst du das Resultat optional in dieser Weise visualisieren.\n\n\n\n\n\n\n",
    "preview": "rauman/RaumAn1_Uebung_B/distill-preview.png",
    "last_modified": "2021-11-29T07:04:10+00:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  }
]
