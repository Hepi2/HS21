[
  {
    "path": "rauman/RaumAn1_Uebung_A/",
    "title": "Übung A",
    "description": {},
    "author": [
      {
        "name": "Patrick Laube",
        "url": {}
      },
      {
        "name": "Nils Ratnaweera",
        "url": {}
      },
      {
        "name": "Nikolaos Bakogiannis",
        "url": {}
      }
    ],
    "date": "2021-11-03",
    "categories": [
      "RaumAn1"
    ],
    "contents": "\n\nContents\nAufgabe 1: Daten runterladen und importieren\nAufgabe 2: Daten Visualisieren\nAufgabe 3: Koordinatensysteme zuweisen\nAufgabe 4: Koordinatensyteme transformieren\n\nEs gibt bereits eine Vielzahl von Packages um in R mit räumlichen Daten zu arbeiten, die ihrerseits wiederum auf weiteren Packages basieren (Stichwort dependencies). Für Vektordaten dominierte lange das Package sp, welches nun durch sf abgelöst wurde.\n\n\nlibrary(sf)\nlibrary(dplyr)\nlibrary(ggplot2)\n\n\n\nAufgabe 1: Daten runterladen und importieren\nLade zunächst die Datensätze unter folgenden Links herunter:\n\nkantone.gpkg (Quelle: Swisstopo)\nbezirke.gpkg (Quelle: Swisstopo)\n\nEs handelt sich um Geodatensätze im Format Geopackage (“*.gpkg”), eine alternatives Datenformat zum bekannteren Format “Shapefiles”. Importiere die Datensätze wie folgt:\n\n\nkantone <- read_sf(\"kantone.gpkg\")\nbezirke <- read_sf(\"bezirke.gpkg\") \n\n\n\nSchau Dir die importierten Datensätze an. Am meisten Informationen zu sf Objekten bekommst du, wenn du dir den Datensatz in der Konsole anschaust (in dem du den Variabel-Name in der Konsole eintippst). Mit dem RStudio Viewer werden sf Objekte nur sehr langsam geladen und die Metadaten werden nicht angezeigt.\nAufgabe 2: Daten Visualisieren\nVektordaten (sf Objekte) lassen sich teilweise sehr schön in die bekannten Tidyverse workflows integrieren. Das merkt man schnell, wenn man die Daten visualisieren möchte. In InfoVis 1 & 2 haben wir intensiv mit ggplot2 gearbeitet und dort die Layers geom_point() und geom_line() kennen gelernt. Zusätzlich beinhaltet ggplot die Möglichkeit, mit geom_sf() Vektordaten direkt und sehr einfach zu plotten. Führe die angegebenen R-Befehle aus und studiere die entstehenden Plots. Welche Unterschiede findest Du? Wie erklärst Du diese Unterschiede?\n\n\nggplot(bezirke) + \n  geom_sf()\n\n\n\n\n\n\nggplot(kantone) + \n  geom_sf()\n\n\n\n\nAufgabe 3: Koordinatensysteme zuweisen\nIn der vorherigen Aufgabe habt ihr kantone.gpkg und bezirke.gpgk visualisiert. Dabei fällt folgendes auf:\ndie X/Y Achsen weisen zwei ganz unterschiedlichen Zahlenbereiche auf (vergleiche die Achsenbeschriftungen)\nder Umriss der Schweiz sieht in den beiden Datensätzen unterschiedlich aus (kantone ist gegenüber bezirke gestaucht)\nDies hat natürlich damit zu tun, dass die beiden Datensätze in unterschiedlichen Koordinatensystemen erfasst wurden. Koordinatensysteme werden mit CRS (Coordinate Reference System) abgekürzt. Mit st_crs() könnnen die zugewiesenen Koordinatensysteme abgefragt werden.\n\n\nst_crs(kantone)\n\n\nCoordinate Reference System: NA\n\nst_crs(bezirke)\n\n\nCoordinate Reference System: NA\n\nLeider sind in unserem Fall keine Koordinatensysteme zugewiesen. Mit etwas Erfahrung kann man das Koordinatensystem aber erraten, so viele kommen nämlich gar nicht in Frage. Am häufigsten trifft man hierzulande eines der drei folgenden Koordinatensysteme an:\nCH1903 LV03: das alte Koordinatensystem der Schweiz\nCH1903+ LV95: das neue Koordinatensystem der Schweiz\nWGS84: ein häufig genutztes weltumspannendes geodätisches Koordinatensystem, sprich die Koordinaten werden in Länge und Breite angegeben (Lat/Lon).\nNun gilt es, anhand der Koordinaten die in der Spalte geometry ersichtlich sind das korrekte Koordinatensystem festzustellen. Wenn man sich auf epsg.io/map die Schweiz anschaut, kann man die Koordinaten in verschiedenen Koordinatensystem betrachten.\nBedienungshinweise:\n\n\n\nKoordinanten (des Fadenkreuzes) werden im ausgewählten Koordinatensystem dargestellt\n\n\n\nDas Koordinatensystem, in welchem die Koordinaten dargestellt werden sollen, kann mit “Change” angepasst werden\n\n\n\nFür Enthusiasten: Schau Dir die Schweiz in verschiedenen Koordinatensystemen an, in dem Du auf “Reproject Map” klickst\n\n\n\nWenn man diese Koordinaten mit den Koordinaten unserer Datensätze vergleicht, dann ist schnell klar, dass es sich beim Datensatz kantone um das Koordinatensystem WGS84 handelt und bei bezirke das Koordinatensystem CH1903+ LV95. Diese Koordinatensyteme weisen wir nun mit st_set_crs() und dem entsprechenden EPSG-Code (siehe die jeweiligen Links) zu.\n\n\nkantone <- st_set_crs(kantone, 4326)\nbezirke <- st_set_crs(bezirke, 2056)\n\n# zuweisen mit st_set_crs(), abfragen mit st_crs()\nst_crs(kantone)\n\n\nCoordinate Reference System:\n  User input: EPSG:4326 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    USAGE[\n        SCOPE[\"Horizontal component of 3D system.\"],\n        AREA[\"World.\"],\n        BBOX[-90,-180,90,180]],\n    ID[\"EPSG\",4326]]\n\nJetzt wo das CRS der Datensätze bekannt ist, können diese in einem gemeinsamen Plot visualisiert werden, ggplot kümmert sich darum die unterschiedlichen Koordinatensysteme zu vereinheitlichen. Probier das aus, indem du kantone und bezirke in einem ggplot kombinierst.\nDie Achsen werden weiterhin in WGS84 beschriftet. Wenn das stört, kann man coord_sf(datum = 2056) in einem weiteren Layer spezifizieren. Oder aber man blendet die Achsenbeschriftung mit theme_void() komplett aus. Versuche beide Varianten.\n\n\n\nAufgabe 4: Koordinatensyteme transformieren\nIn der vorherigen Übung haben wir das bestehende Koordinatensystem zugewiesen. Dabei haben wir die bestehenden Koordinaten (in der Spalte geom) nicht manipuliert. Ganz anders ist eine Transformation der Daten von einem Koordinatensystem in das andere. Bei einer Transformation werden die Koordinaten in das neue Koordinatensystem umgerechnet und somit manipuliert. Aus praktischen Gründen wollen  wir all unsere Daten ins neue Schweizer Koordinatensystem CH1903+ LV95 transfomieren. Transformiere den Datensatz kantone mit st_transform()in CH1903+ LV95, nutze dafür den korrekten EPSG-Code.\nVor der Transformation (betrachte die Attribute Bounding box sowie CRS-Information):\n\n\nkantone\n\n\nSimple feature collection with 51 features and 6 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 5.955902 ymin: 45.81796 xmax: 10.49217 ymax: 47.80845\nGeodetic CRS:  WGS 84\n# A tibble: 51 × 7\n   NAME            KANTONSNUM SEE_FLAECH KANTONSFLA KT_TEIL EINWOHNERZ\n * <chr>                <dbl>      <dbl>      <dbl> <chr>        <dbl>\n 1 Aargau                  19        870     140380 1           685845\n 2 Aargau                  19         NA         NA 2               NA\n 3 Appenzell Auss…         15         NA      24284 0            55445\n 4 Appenzell Inne…         16         NA      17248 1            16128\n 5 Appenzell Inne…         16         NA         NA 2               NA\n 6 Appenzell Inne…         16         NA         NA 3               NA\n 7 Appenzell Inne…         16         NA         NA 4               NA\n 8 Appenzell Inne…         16         NA         NA 5               NA\n 9 Basel-Landscha…         13         NA      51767 1           289468\n10 Basel-Landscha…         13         NA         NA 2               NA\n# … with 41 more rows, and 1 more variable: geom <POLYGON [°]>\n\n\n\nkantone <- st_transform(kantone, 2056)\n\n\n\nNach der Transformation (betrachte die Attribute Bounding box sowie CRS-Information):\n\n\nkantone\n\n\nSimple feature collection with 51 features and 6 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2485410 ymin: 1075268 xmax: 2833858 ymax: 1295934\nProjected CRS: CH1903+ / LV95\n# A tibble: 51 × 7\n   NAME            KANTONSNUM SEE_FLAECH KANTONSFLA KT_TEIL EINWOHNERZ\n * <chr>                <dbl>      <dbl>      <dbl> <chr>        <dbl>\n 1 Aargau                  19        870     140380 1           685845\n 2 Aargau                  19         NA         NA 2               NA\n 3 Appenzell Auss…         15         NA      24284 0            55445\n 4 Appenzell Inne…         16         NA      17248 1            16128\n 5 Appenzell Inne…         16         NA         NA 2               NA\n 6 Appenzell Inne…         16         NA         NA 3               NA\n 7 Appenzell Inne…         16         NA         NA 4               NA\n 8 Appenzell Inne…         16         NA         NA 5               NA\n 9 Basel-Landscha…         13         NA      51767 1           289468\n10 Basel-Landscha…         13         NA         NA 2               NA\n# … with 41 more rows, and 1 more variable: geom <POLYGON [m]>\n\n\n\n\n",
    "preview": "rauman/RaumAn1_Uebung_A/distill-preview.png",
    "last_modified": "2021-11-08T08:22:53+00:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "rauman/RaumAn2_Uebung_A/",
    "title": "Übungen A",
    "description": "Analyse von Punktverteilungen",
    "author": [
      {
        "name": "Patrick Laube",
        "url": {}
      },
      {
        "name": "Nils Ratnaweera",
        "url": {}
      },
      {
        "name": "Nikolaos Bakogiannis",
        "url": {}
      }
    ],
    "date": "2021-11-01",
    "categories": [
      "RaumAn2"
    ],
    "contents": "\n\n\n\nlibrary(gstat)\nlibrary(sf)\nlibrary(tidyverse)\nlibrary(lubridate)\nlibrary(stars)\n\nluftqualitaet <- read_sf(\"luftqualitaet.gpkg\")\nkantone <- read_sf(\"kantone.gpkg\")\nrotmilan <- read_sf(\"rotmilan.gpkg\")\n\n\nluftqualitaet <- st_set_crs(luftqualitaet,2056)\nkantone <- st_set_crs(kantone, 2056)\nrotmilan <- st_set_crs(rotmilan, 2056)\n\n\n\nAls erstes berechnen wir die G-Function für die Rotmilanpositionen wie auch für die Luftqualitätsmessungen NO2:\nSchritt 1: Da es sich beim Rotmilan um relativ viele Datenpunkte handelt, nehmen wir mit st_sample() ein subset aus dem Datensatz. Dies verkürzt die Rechenzeit substantiell und verändert die Resultate kaum.\n\n\nrotmilan_sample <- sample_n(rotmilan,1000)\n\n\n\nSchritt 2: Mit st_distance() können Distanzen zwischen zwei sf Datensätze berechnet werden. Wird nur ein Datensatz angegeben, wird eine Kreuzmatrix erstellt wo die Distanzen zwischen allen Features zu allen anderen Features dargestellt werden. Wir nützen diese Funktion zur Berechnung der nächsten Nachbarn.\n\n\nrotmilan_distanzmatrix <- st_distance(rotmilan_sample)\n\n# zeige die ersten 6 Zeilen und Spalten der Matrix\n# jeder Distanz wurde 2x Gemessen (vergleiche Wert [2,1] mit [1,2])\n# die Diagonale ist die Distanz zu sich selber (gleich 0)\nrotmilan_distanzmatrix[1:6,1:6] \n\n\nUnits: [m]\n          [,1]      [,2]      [,3]     [,4]     [,5]     [,6]\n[1,]     0.000  2658.185  2378.256 53372.30 35776.05 14058.65\n[2,]  2658.185     0.000  3730.182 55806.69 33118.53 15130.58\n[3,]  2378.256  3730.182     0.000 52236.46 36128.59 11759.22\n[4,] 53372.297 55806.694 52236.457     0.00 87427.52 44942.18\n[5,] 35776.049 33118.531 36128.588 87427.52     0.00 42708.51\n[6,] 14058.647 15130.580 11759.216 44942.18 42708.51     0.00\n\nSchritt 3: Nun wollen wir wissen, wie gross die kürzeste Distanz von jedem Punkt zu seinem nächsten Nachbarn beträgt, also die kürzeste Distanz pro Zeile. Zuerst aber müssen wir die diagonalen Werte noch entfernen, denn diese stellen ja jeweils die Distanz zu sich selber dar und sind immer 0. Danach kann mit apply() eine Funktion (FUN = min) über die Zeilen (MARGIN = 1) einer Matrix (X = rotmilan_distanzmatrix) gerechnet werden. Zusätzlich müssen wir noch na.rm = TRUE setzen, damit NA Werte von der Berechnung ausgeschlossen werden. Das Resultat ist ein Vektor mit gleich vielen Werten wie Zeilen in der Matrix.\n\n\ndiag(rotmilan_distanzmatrix) <- NA # entfernt alle diagonalen Werte\n\nrotmilan_mindist <- apply(rotmilan_distanzmatrix,1,min, na.rm = TRUE)\n\n\n\nNun wollen wir die kumulierte Häufigkeit der Werte in einer Verteilungsfunktion (engl: Empirical Cumulative Distribution Function, ECDF) darstellen. Dafür müssen wir den Vektor zuerst noch in einen Dataframe packen, damit ggplot damit klar kommt:\n\n\nrotmilan_mindist_df <- data.frame(distanzen = rotmilan_mindist)\n\nggplot() + geom_step(data = rotmilan_mindist_df, aes(distanzen),stat = \"ecdf\")\n\n\n\n\nFühre nun die gleichen Schritte mit luftqualitaet durch und vergleiche die ECDF-Plots. Hinweis: st_sample() ist bei luftqualitaet nicht nötig, da es sich hier um einen kleineren Datensatz handelt.\n\n\nluftqualitaet_distanzmatrix <- st_distance(luftqualitaet)\n\ndiag(luftqualitaet_distanzmatrix) <- NA\n\nluftqualitaet_mindist <- apply(luftqualitaet_distanzmatrix,1,min,na.rm = TRUE)\n\nluftqualitaet_mindist_df <- data.frame(distanzen = luftqualitaet_mindist, data = \"Luftqualität\")\n\nrotmilan_mindist_df$data <- \"Rotmilan\"\n\nmindist_df <- rbind(luftqualitaet_mindist_df,rotmilan_mindist_df)\n\nggplot() + \n  geom_step(data = mindist_df, aes(distanzen, colour = data),stat = \"ecdf\") +\n  labs(colour = \"Datensatz\")\n\n\n\n\n\n\n\n",
    "preview": "rauman/RaumAn2_Uebung_A/distill-preview.png",
    "last_modified": "2021-11-08T08:22:53+00:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  }
]
