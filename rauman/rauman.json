[
  {
    "path": "rauman/RaumAn1_Uebung_C/",
    "title": "Übung B Spatial Joins",
    "description": {},
    "author": [
      {
        "name": "Patrick Laube",
        "url": {}
      },
      {
        "name": "Nils Ratnaweera",
        "url": {}
      },
      {
        "name": "Nikolaos Bakogiannis",
        "url": {}
      }
    ],
    "date": "2021-11-26",
    "categories": [
      "RaumAn1"
    ],
    "contents": "\n\nContents\nAufgabe 1: Geopackage “Layers”\nAufgabe 2: Datensätze erkunden\nAufgabe 3: Spatial Join mit Punkten\nAufgabe 4: Spaital Join mit Flächen\n\n\n\n\nFür die kommende Übung arbeiten wir mit nachstehendem Datensatz. Lade diesen Herunter und importiere ihn in R.\n\ngruental.gpkg\n\nZudem brauchen wir die folgenden libraries:\n\n\nlibrary(dplyr)\nlibrary(sf)\nlibrary(ggplot2)\n\n\n\nAufgabe 1: Geopackage “Layers”\nAllenfalls ist euch beim Importieren des Geopackage gruental.pgkg folgende Warnmeldung aufgefallen:\nWarning message:\nIn evalq((function (..., call. = TRUE, immediate. = FALSE, noBreaks. = FALSE,  :\n  automatically selected the first layer in a data source containing more than one.\nDiese Warnmeldung weist darauf hin, dass das Geopackage gruental.gpkg mehrere Layers (rep. Datensätze) enthält und nur der erste Layer importiert wurde. Bringe mit dem Befehl st_layers die Layer Namen in Erfahrung und nutze diese im Anschluss in st_read (als Argument layer =) um die layers einzeln zu importieren und in variablen zu speichern (zB in als Variable wiesen und baeume).\nAufgabe 2: Datensätze erkunden\nNimm dir etwas Zeit und erkunde die beiden Datensätze. Nutze dafür auch die Visualisierungsmöglichkeiten von ggplot (insbesondere geom_sf).\n\n\n\nFigure 1: Beispielsweise kannst du die Daten in dieser Weise visualisieren.\n\n\n\nAufgabe 3: Spatial Join mit Punkten\nWir wollen nun für jeden Baum wissen, ob er sich in einer Wiese befindet oder nicht. Dazu nutzen wir die GIS-Technik Spatial Join, die in der Vorlesung beschrieben wurde. In sf können wir Spatial Joins mit der Funktion st_join durchführen, dabei gibt es nur left sowie inner-Joins (vgl. PrePro 1 & 2). So müssen die Punkte “Links”, also an erste Stelle aufgeführt werden, da wir ja Attribute an die Punkte anheften wollen.\nBeachte, dass der Output eine neue Spalte flaechen_typ aufweist. Diese ist leer (NA) wenn sich der entsprechende Baum nicht in einer Wiese befindet. Wie viele Bäume befinden sich in einer Wiese, wie viele nicht?\n\n\n\nAufgabe 4: Spaital Join mit Flächen\nAnalog der Vorlesung wollen wir nun in Erfahrung bringen, wie hoch der Wiesen-Anteil im Umkreis von 20m um jeden Baum ist. Dazu sind folgende Schritte nötig:\nAls erster Schritt müssen wir jeden Baum mit einem 20m Puffer verstehen. Nutze dazu st_buffer um speichere den Output als baeume_20m. Schau dir baeume_20m nun genau an. Um welchen Geometrietyp handelt es sich dabei nun?\nBerechnen nun die Schnittmenge aus baeume_20m und wiesen mit der Funktion st_intersection und speichere den Output als baeume_wiesen. Exploriere nun baeume_wiesen, auch mit ggplot(). Was ist passiert? Überprüfe die Anzahl Zeilen pro Datensatz. Haben die sich verändert? Wenn ja, warum?\nBerechnen nun die Flächengrösse pro Geometrie mit der Funktion st_area(). Speichere den Output in einer neuen Spalte von baeume_wiesen (z.B. mit dem Namen wiesen_flaeche). Tipp: Konvertiere den Output aus st_area einen nummerischen Vektor mit as.numeric().\nBerechne nun aus wiesen_flaeche den wiesen_anteil. Tipp: 100% ist die Kreisfläche aus \\(r^2\\times \\pi\\), wobei in unserem Fall \\(r = 20\\) entspricht.\nUm die berechneten Werte in den Datensatz baeume zu überführen braucht es noch folgende Schritte:\nKonvertiere baeume_wiesen in eine data.frame mit st_drop_geometry und speichere diese als baeume_wiesen_df\nNutze die Spalte baum_id in baeume_wiesen_df um den berechneten wiesen_anteil in den Datenatz baeume zu überführen. Tipp: Nutze dafür einen left_join\nErsetze alle NA Werte in der Spalte wiesen_anteil mit 0.\n\n\n\n\n\n\nFigure 2: Nach dieser Übung kannst du das Resultat optional in dieser Weise visualisieren.\n\n\n\n\n\n\n",
    "preview": "rauman/RaumAn1_Uebung_C/distill-preview.png",
    "last_modified": "2021-11-26T12:22:09+00:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "rauman/RaumAn2_Uebung_A/",
    "title": "Übungen A",
    "description": "Analyse von Punktverteilungen",
    "author": [
      {
        "name": "Patrick Laube",
        "url": {}
      },
      {
        "name": "Nils Ratnaweera",
        "url": {}
      },
      {
        "name": "Nikolaos Bakogiannis",
        "url": {}
      }
    ],
    "date": "2021-11-01",
    "categories": [
      "RaumAn2"
    ],
    "contents": "\n\n\n\nlibrary(gstat)\nlibrary(sf)\nlibrary(tidyverse)\nlibrary(lubridate)\nlibrary(stars)\n\nluftqualitaet <- read_sf(\"luftqualitaet.gpkg\")\nkantone <- read_sf(\"kantone.gpkg\")\nrotmilan <- read_sf(\"rotmilan.gpkg\")\n\n\nluftqualitaet <- st_set_crs(luftqualitaet,2056)\nkantone <- st_set_crs(kantone, 2056)\nrotmilan <- st_set_crs(rotmilan, 2056)\n\n\n\nAls erstes berechnen wir die G-Function für die Rotmilanpositionen wie auch für die Luftqualitätsmessungen NO2:\nSchritt 1: Da es sich beim Rotmilan um relativ viele Datenpunkte handelt, nehmen wir mit st_sample() ein subset aus dem Datensatz. Dies verkürzt die Rechenzeit substantiell und verändert die Resultate kaum.\n\n\nrotmilan_sample <- sample_n(rotmilan,1000)\n\n\n\nSchritt 2: Mit st_distance() können Distanzen zwischen zwei sf Datensätze berechnet werden. Wird nur ein Datensatz angegeben, wird eine Kreuzmatrix erstellt wo die Distanzen zwischen allen Features zu allen anderen Features dargestellt werden. Wir nützen diese Funktion zur Berechnung der nächsten Nachbarn.\n\n\nrotmilan_distanzmatrix <- st_distance(rotmilan_sample)\n\n# zeige die ersten 6 Zeilen und Spalten der Matrix\n# jeder Distanz wurde 2x Gemessen (vergleiche Wert [2,1] mit [1,2])\n# die Diagonale ist die Distanz zu sich selber (gleich 0)\nrotmilan_distanzmatrix[1:6,1:6] \n\n\nUnits: [m]\n          [,1]      [,2]      [,3]     [,4]     [,5]     [,6]\n[1,]     0.000  2658.185  2378.256 53372.30 35776.05 14058.65\n[2,]  2658.185     0.000  3730.182 55806.69 33118.53 15130.58\n[3,]  2378.256  3730.182     0.000 52236.46 36128.59 11759.22\n[4,] 53372.297 55806.694 52236.457     0.00 87427.52 44942.18\n[5,] 35776.049 33118.531 36128.588 87427.52     0.00 42708.51\n[6,] 14058.647 15130.580 11759.216 44942.18 42708.51     0.00\n\nSchritt 3: Nun wollen wir wissen, wie gross die kürzeste Distanz von jedem Punkt zu seinem nächsten Nachbarn beträgt, also die kürzeste Distanz pro Zeile. Zuerst aber müssen wir die diagonalen Werte noch entfernen, denn diese stellen ja jeweils die Distanz zu sich selber dar und sind immer 0. Danach kann mit apply() eine Funktion (FUN = min) über die Zeilen (MARGIN = 1) einer Matrix (X = rotmilan_distanzmatrix) gerechnet werden. Zusätzlich müssen wir noch na.rm = TRUE setzen, damit NA Werte von der Berechnung ausgeschlossen werden. Das Resultat ist ein Vektor mit gleich vielen Werten wie Zeilen in der Matrix.\n\n\ndiag(rotmilan_distanzmatrix) <- NA # entfernt alle diagonalen Werte\n\nrotmilan_mindist <- apply(rotmilan_distanzmatrix,1,min, na.rm = TRUE)\n\n\n\nNun wollen wir die kumulierte Häufigkeit der Werte in einer Verteilungsfunktion (engl: Empirical Cumulative Distribution Function, ECDF) darstellen. Dafür müssen wir den Vektor zuerst noch in einen Dataframe packen, damit ggplot damit klar kommt:\n\n\nrotmilan_mindist_df <- data.frame(distanzen = rotmilan_mindist)\n\nggplot() + geom_step(data = rotmilan_mindist_df, aes(distanzen),stat = \"ecdf\")\n\n\n\n\nFühre nun die gleichen Schritte mit luftqualitaet durch und vergleiche die ECDF-Plots. Hinweis: st_sample() ist bei luftqualitaet nicht nötig, da es sich hier um einen kleineren Datensatz handelt.\n\n\nluftqualitaet_distanzmatrix <- st_distance(luftqualitaet)\n\ndiag(luftqualitaet_distanzmatrix) <- NA\n\nluftqualitaet_mindist <- apply(luftqualitaet_distanzmatrix,1,min,na.rm = TRUE)\n\nluftqualitaet_mindist_df <- data.frame(distanzen = luftqualitaet_mindist, data = \"Luftqualität\")\n\nrotmilan_mindist_df$data <- \"Rotmilan\"\n\nmindist_df <- rbind(luftqualitaet_mindist_df,rotmilan_mindist_df)\n\nggplot() + \n  geom_step(data = mindist_df, aes(distanzen, colour = data),stat = \"ecdf\") +\n  labs(colour = \"Datensatz\")\n\n\n\n\n\n\n\n",
    "preview": "rauman/RaumAn2_Uebung_A/distill-preview.png",
    "last_modified": "2021-11-26T12:22:09+00:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  }
]
