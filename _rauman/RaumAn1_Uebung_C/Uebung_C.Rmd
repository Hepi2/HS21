---
title: Übung C Spatial Joins
output: 
  distill::distill_article:
    toc: true
categories:
- RaumAn1
draft: true
author:
  - name: Patrick Laube
  - name: Nils Ratnaweera
  - name: Nikolaos Bakogiannis
---


```{r, echo = FALSE, purl = FALSE, results = "asis"}

check_download <- function(file, folder, url = "https://github.com/ResearchMethods-ZHAW/datasets/raw/main/"){
  full_url <- paste0(url,folder,"/",file)
  if(!file.exists(file)){
    download.file(full_url,file)
  }
  paste0("[",file,"](",full_url,")")
}

check_download("kantone.gpkg", "rauman")
check_download("bezirke.gpkg", "rauman")

check_download("bodeneignung_skelett.gpkg", "rauman")

check_download("bodeneignung_skelett.tif", "rauman")
check_download("wasserverfuegbarkeit_boden.gpkg", "rauman")
```

```{r}
library(dplyr)
library(sf)
library(ggplot2)
library(terra)

skelettgehalt <- read_sf("bodeneignung_skelett.gpkg")
st_crs(skelettgehalt) <- 2056

wasser <- read_sf("wasserverfuegbarkeit_boden.gpkg")
st_crs(wasser) <- 2056

st_crs(wasser) <- 2056

kantone <- read_sf("kantone.gpkg")

st_crs(kantone) <- 4326
kantone <- st_transform(kantone, 2056)

bezirke <- read_sf("bezirke.gpkg")
st_crs(bezirke) <- 2056

```


### Aufgabe 1: Spatialjoin mit Punkten


Wir wollen nun wissen, ob die Wasserverfügbarkeit im Boden mit dem Skelettgehalt zusammen hängt. Dazu nutzen wir die GIS-Technik *Spatial Join*, die in der Vorlesung beschrieben wurde. In `sf` können wir Spatial Joins mit der Funktion `st_join` durchführen, dabei gibt es nur `left` sowie `inner`-Joins (vgl. PrePro 1 & 2). So müssen die Punkte "Links", also an erste Stelle aufgeführt werden, da wir ja Attribute *an* die Punkte anheften wollen.

```{r, echo = FALSE}
wasser_skelett <- st_join(wasser,skelettgehalt)
wasser_skelett
```

Führe den obigen Spatial Join aus und erstelle anschliessend einen Boxplot pro Skelett-Kategorie. Für `ggplot` boxplots ist es sinnvoll, den Skelettgehalt vorgängig von `numeric` in `factor` zu konvertieren (falls Du nicht mehr weisst weshalb, schau nochmals nach in PrePro und InfoVis).

Nun haben wir das Ziel der Aufgabe erreicht und die Messpunkte durch räumliche Zusatzinformation aufgewertet. Wir werden das Resultat an dieser Stelle aber nicht weiter interpretieren, dass wäre Teil einer Bodenkunde Vorlesung.

```{r}

wasser_skelett %>%
  mutate(SKELETT = factor(SKELETT)) %>%
  ggplot() +  
  geom_boxplot(aes(SKELETT,wasserverfuegbarkeit))
```



### Aufgabe 2: Spatial Join mit Flächen



In der letzten Aufgabe haben wir für jede Probe aus `wasser` den Skelettgehalt des darunterliegenden Polygons ermittelt. Für Proben, die gerade an der Grenze zu einem Polygon mit einem anderen Skelettgehalt liegen ist dieser Wert aber nicht sehr aussagekräftig. 

So könnte es zum Beispiel wichtiger sein zu wissen, was *der dominierende Skelettgehalt innerhalb eines 2 km Radius* um die Probe ist. In den kommenden Teilaufgaben lösen wir diese Herausforderung.

#### Punkte mit Puffer versehen

Dafür müssen wir die Punkte mit einem Puffer versehen. Dies erreichen wir mit `st_buffer()`. Erstelle einen Datensatz `wasser_2km`, in dem jeder Punkt mit 2'000 m gepuffert wurde. Visualisiere dann diesen Datensatz. Beachte, dass es sich nun nicht mehr um Punkte, sondern um Flächen handelt (`POLYGON`).

```{r}
wasser_2km <- st_buffer(wasser,2000)
```

```{r}
ggplot(wasser_2km) + geom_sf(fill = "blue")
```

#### Werte extrahieren

Um den dominierendenSkelettegehalt innerhalb des 2km Puffers zu extrahieren, müssen wir mit Rasterdaten arbeiten. Lade dazu den Rasterdatensatz [bodeneignung_skelett.tif](https://github.com/ResearchMethods-ZHAW/datasets/raw/main/rauman/bodeneignung_skelett.tif) herunter un importiere diesen mit `terra::rast()`.

Um die Raster daten zu visualisieren gibt es ganz verschiedene Methoden. Die einfachste Methode ist wohl `plot()`. Wir können raster aber auch mit `ggplot2` plotten, benötigen dafür aber die neuste Version der ggplot-Erweiterung `ggspatial`. Installiere diese mit `remotes::install_github("paleolimbot/ggspatial")`.

```{r}

skelett_raster <- terra::rast("bodeneignung_skelett.tif")

```


```{r, eval = FALSE}
remotes::install_github("paleolimbot/ggspatial")
```


```{r, echo = TRUE}
library(ggspatial) 
ggplot() + 
  layer_spatial(skelett_raster) # <- visualisiert den Rasterdatensatz
```


Mit `raster::extract()` könnnen nun die Rasterwerte aus dem Rasterdatensatz extrahiert werden. In `fun = ` kann festgelegt werden, ob und mit welcher Funktion die vielen Rasterzellen pro Polygon aggregiert werden sollen. Wir möchten nur den häufigsten Wert zurück erhalten, sprich den [Modus](https://de.wikipedia.org/wiki/Modus_(Statistik)) dafür gibt es in `R` leider keine eingebaute Funktion, weshalb wir unsere eigene basteln müssen:

```{r, echo = TRUE}
mode <- function(x,na.rm = FALSE) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}
```

Nun können wir mit `terra::extract()` den Modus in jedem Puffer berechnen.

```{r, echo = TRUE}
wasser_skelett$skelett_mode <- extract(skelett_raster,as(wasser_skelett, "SpatVector"),fun = mode)[,2]
```

Jetzt könnnen wir prüfen, wie oft die beiden Join-Varianten übereinstimmen. Erstelle dazu einen Facet-Plot, indem für jede Skelett-Kategorie die Modus-Kategorie (sprich die häufigste Kategorie) im den Punkt umgebenden Puffer darstellt.

```{r}

wasser_skelett %>%
  st_drop_geometry() %>%
  group_by(SKELETT, skelett_mode) %>%
  count() %>%
  ggplot(aes(SKELETT, skelett_mode, fill = n)) +
  geom_raster()
```


### Aufgabe 3: Spatial Join mit Kantone, Bezirke



Zum Abschluss der Übung wenden wir uns nun noch der Aggregationsabhängigkeit von Geodaten zu. Dazu wollen wir die Daten zur Wasserverfügbarkeit auf verschiedenen Massstäben aggregieren. Als Aggregationseinheiten verwenden wir zwei politische Gliederungen der Schweit - Kantone und Bezirke. Die Frage stellt sich, ob die Daten ev. das MAUP illustrieren.

Hier könnten wir nochmals `st_join()` verwenden, aber da wir diesmal Polygone im Fokus haben (Bezirke, Kantone) und mehrere Punkte in einem Polygon vorkommen können, ist dieser Weg etwas umständlich. Wir nutzen deshalb die Funktion `aggregate()`, und spezifizieren `x = wasser`, `by = kantone` und `FUN = mean`.

Hinweis: Das Beschriften der Kantone ist fakultativ und nicht *ganz* trivial.

```{r}
library(ggrepel)
```

```{r}

aggregate(x = wasser, by = kantone, FUN = mean) %>%
  ggplot() + 
  geom_sf(aes(fill = wasserverfuegbarkeit)) + 
  geom_sf(data = wasser,size = 0.1) +  
  geom_text_repel(
    data = summarise(group_by(kantone,NAME)),
    aes(label = NAME, geometry = geom),
    stat = "sf_coordinates"
  ) +
  labs(title = "Mittlere Wasserverfügbarkeit im Boden", subtitle = "pro Kanton", fill = "") +
  theme_void() +
  theme(legend.position = "bottom",legend.direction = "horizontal") 


aggregate(wasser, bezirke, mean) %>%
  ggplot() + 
  geom_sf(aes(fill = wasserverfuegbarkeit)) + 
  geom_sf(data = wasser,size = 0.1) +
  geom_sf(data = kantone, fill = NA, colour = "grey") +
  labs(title = "Mittlere Wasserverfügbarkeit im Boden", subtitle = "pro Bezirk", fill = "") +
  theme_void() +
  theme(legend.position = "bottom",legend.direction = "horizontal") 
```

