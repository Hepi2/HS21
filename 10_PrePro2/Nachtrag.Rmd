```{r, include=F, purl=F}
library(knitr)
knitr::opts_chunk$set(echo = TRUE,include = T, collapse=TRUE)
```

## Ergänzungen zu PrePro 1

### Integer mit "L"

In `R` kann eine Zahl mit dem Suffix "L" explizit als Integer spezifiziert werden. 

```{r, parse = F}
typeof(42)
typeof(42L)
```


Warum dazu der Buchstabe "L" verwendet wird ist nirgends offiziell Dokumentiert (zumindest haben wir nichts gefunden). Die gängigste Meinung, die auch [von renommierten R-Profis vertreten wird](https://hypatia.math.ethz.ch/pipermail/r-devel/2017-June/074467.html
) ist, dass damit `Long integer` abgekürzt wird.



### Arbeiten mit RStudio "Project"

Wir empfehlen die Verwendung von "Projects" innerhalb von RStudio. RStudio legt für jedes Projekt dann einen Ordner an, in welches die Projekt-Datei abgelegt wird (Dateiendung .Rproj). Sollen innerhalb des Projekts dann R-Skripts geladen oder erzeugt werden, werden diese dann auch im angelegten Ordner abgelegt. Mehr zu RStudio Projects findet ihr  [hier](https://support.rstudio.com/hc/en-us/articles/200526207-Using-Projects).


Das Verwenden von Projects bringt verschiedene Vorteile, wie zum Beispiel:

- Festlegen der Working Directory ohne die Verwendung des expliziten Pfades (`setwd()`). Das ist sinnvoll, da sich dieser Pfad ändern kann (Zusammenarbeit mit anderen Usern, Ausführung des Scripts zu einem späteren Zeitpunkt) 
- Automatisches Zwischenspeichern geöffneter Scripts und Wiederherstellung der geöffneten Scripts bei der nächsten Session
- Festlegen verschiedener projektspezifischer Optionen
- Verwendung von Versionsverwaltungssystemen (Github oder SVN)



### Arbeiten mit `factors`

Wie bereits angedeutet, ist das Arbeiten mit `factors` etwas gewöhnungsbedürftig. Wir gehen hier auf ein paar Stolpersteine ein.

```{r}
zahlen <- factor(c("null","eins","zwei","drei"))

zahlen
```

Offensichtlich sollten diese `factors` geordnet sein, R weiss davon aber nichts. Eine Ordnung kann man mit dem Befehl `ordered = T` festlegen. 

Beachtet: `ordered = T` kann nur bei der Funktion `factor()` spezifiziert werden, nicht bei `as.factor()`. Ansonsten sind `factor()` und `as.factor()` sehr ähnlich.


```{r}
zahlen <- factor(zahlen,ordered = T)

zahlen
```

Beachtet das "<"-Zeichen zwischen den Levels. Die Zahlen werden nicht in der korrekten Reihenfolge, sondern Alphabetisch geordnet. Die richtige Reihenfolge kann man mit `levels = ` festlegen.

```{r}
zahlen <- factor(zahlen,ordered = T,levels = c("null","eins","zwei","drei","vier"))

zahlen
```

Wie auch schon erwähnt werden `factors` als `character` Vektor dargestellt, aber als Integers gespeichert. Das führt zu einem scheinbaren Wiederspruch wenn man den Datentyp auf unterschiedliche Weise abfragt.
```{r}
typeof(zahlen)

is.integer(zahlen)
```


Mit `typeof()` wird eben diese Form der Speicherung abgefragt und deshalb mit `integer` beantwortet. Da es sich aber nicht um einen eigentlichen Integer Vektor handelt, wird die Frage `is.integer()` mit `FALSE` beantwortet. Das ist etwas verwirrend, beruht aber darauf, dass die beiden Funktionen die Frage von unterschiedlichen Perspektiven beantworten. In diesem Fall schafft `class()` Klarheit:

```{r}
class(zahlen)
```


Wirklich verwirrend wird es, wenn `factors` in numeric umgewandelt werden sollen.

```{r}
zahlen
as.integer(zahlen)
```

Das die Übersetzung der auf Deutsch ausgeschriebenen Nummern in nummerische Zahlen nicht funktionieren würde, war ja klar. Weniger klar ist es jedoch, wenn die `factors` bereits aus nummerischen Zahlen bestehen.

```{r}
zahlen2 <- factor(c("3","2","1","0"))

as.integer(zahlen2)

```

In diesem Fall müssen die `factors` erstmals in `character` umgewandelt werden.

```{r}
zahlen2 <- factor(c("3","2","1","0"))

as.integer(as.character(zahlen2))
```




### Heikle Annahmen - bessere Alternativen

Aus oben beschriebenen Grund ist es auch problematisch, dass `data.frame()` sowie alle `read.*` Funktionen (`read.table`, `read.csv` etc) immer davon ausgehen, dass `strings` als `factors` interpretiert werden sollten. Es gibt in Base R einige Funktionen, welche Annahmen treffen die problematisch sein können. Ein weiteres Beispiel ist die Annahme der Zeitzone und Verwendung von Sommerzeit bei `as.POSIXct()`.

Oft gibt es dafür im Tidyverse alternative Funktionen, in denen diese Probleme besser gelöst sind. Wir empfehlen, wenn immer Möglich die Tidyverse-Alternativen zu verwenden. Beispiele:

- `data_frame()` statt `data.frame()` 
- `read_*` statt `read.*`
- `parse_datetime` statt `as.POSIXct()`


Beim Import von Daten kann es sinnvoll sein, die Datentypen der Spalten bereits _im Importbefehl_ zu spezifizieren. So vermeidet man die anschliessende  Typumwandlung und die damit verbundenen Fehlerquellen. Zudem wird der Importprozess beschleunigt, da R keine Zeit daran verschwenden muss die Datentypen (aufgrund der ersten 1000 Zeilen) zu erraten.

```{r,message=FALSE, eval = FALSE}

library(tidyverse)

df1 <- read_table("09_PrePro1/data/order_52252_data.txt",
                  col_types = list(
                    col_character(),                  # Macht aus der 1.Spalte ein character
                    col_datetime(format = "%Y%m%d%H"),# Macht aus der 2.Spalte ein POSIXct
                    col_double()                      # Macht aus der 3.Spalte ein double
                    )
                  )


df1 <- read_table("09_PrePro1/data/order_52252_data.txt",
                  col_types = list(
                    col_factor(levels = NULL),        # Macht aus der 1.Spalte ein factor
                    col_datetime(format = "%Y%m%d%H"),# Macht aus der 2.Spalte ein POSIXct
                    col_double()                      # Macht aus der 3.Spalte ein double
                    )
                  )



```


