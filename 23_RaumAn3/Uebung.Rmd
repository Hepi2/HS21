```{r, include=FALSE, purl = FALSE}
knitr::opts_chunk$set(echo = FALSE,include = TRUE,message = FALSE, collapse=TRUE, warning=FALSE, results = "markup", fig.width = 7, fig.height = 5) 
```

## Vorbereitung

```{r}
mornans_i <- function(sf_object,col) {
  require(sf)
  n <- nrow(sf_object)
  y <- unlist(st_set_geometry(sf_object,NULL)[,col],use.names = FALSE)
  ybar <- mean(y, na.rm = TRUE)
  dy <- y - ybar
  dy_sum <- sum(dy^2, na.rm = TRUE)
  vr <- n/dy_sum
  w <- st_touches(sf_object, sparse = FALSE)
  w <- w*1
  pm <- tcrossprod(dy)
  pmw <- pm * w
  spmw <- sum(pmw, na.rm = TRUE)
  smw <- sum(w, na.rm = TRUE)
  sw  <- spmw / smw
  MI <- vr * sw
  MI
}
```



```{r, echo = TRUE}
library(tidyverse)
library(sf)

gemeinden <- read_sf("21_RaumAn1/data/gemeinden.gpkg")
kantone <- read_sf("21_RaumAn1/data/kantone.gpkg")

luftqualitaet <- read_sf("22_RaumAn2/data/luftqualitaet.gpkg")

luftqualitaet <- st_set_crs(luftqualitaet, 2056)
gemeinden <- st_set_crs(gemeinden, 2056)

kantone <- st_set_crs(kantone, 2056)
```


```{r}
brett <- st_multipoint(matrix(c(0,0,1,0,1,1,0,1),ncol = 2,byrow = TRUE)) %>%
  st_make_grid(n = c(10,10)) %>%
  st_as_sf() 
  
schachbrett <- brett %>%
  mutate(
    wert = rep(c(rep(c(1,0),5),rep(c(0,1),5)),5)
    )

ggplot(schachbrett) + geom_sf(aes(fill = factor(wert))) + 
  scale_fill_manual(values = c("black","white")) + 
  theme_void() +
  theme(legend.position = "none")
```

```{r, echo = TRUE}
mornans_i(sf_object = schachbrett,col = "wert")

```


```{r}
brett1 <- brett %>% 
  mutate(wert = c(rep(1,50),rep(2,50)))

ggplot(brett1) + geom_sf(aes(fill = factor(wert))) + 
  scale_fill_manual(values = c("black","white")) + 
  theme_void() +
  theme(legend.position = "none")

```

```{r, echo = TRUE}
mornans_i(sf_object = brett1,col = "wert")

```



Mittlere Luftqualität pro Kanton

<!-- würde ich ersetzen mit Abstimmungsresultaten -->


```{r, echo = TRUE}

kantone_union <- kantone %>% group_by(NAME, KANTONSNUM) %>% summarise()


kantone_luftqual <- aggregate(luftqualitaet, kantone_union, mean, na.rm = TRUE)

ggplot(kantone_luftqual) + geom_sf(aes(fill = value))
```


Hier ist die Formel von Morans $I$. Diese sieht extrem komplex aus, wenn wir sie aber Schrittweise angehen dann ist die Sache halb so wild. 

$$I = \frac{n}{\sum_{i=1}^n (y_i - \bar{y})^2} \times \frac{\sum_{i=1}^n \sum_{j=1}^n w_{ij}(y_i - \bar{y})(y_j - \bar{y})}{\sum_{i=1}^n \sum_{j=1}^n w_{ij}}$$

In der Reihenfolge müssen wir...

1. ... als erstes die Teile lösen, die nach den Summenzeichen ($\sum$) stehen
2. ... danach diese Teile summieren
3. ... die Brüche Lösen
4. ... die Faktoren miteinander Multiplizieren.

Beginnen wir mit dem ersten Term: $n$ im ersten Bruch. Dies ist lediglich die Anzahl Polygone in unserem Datensatz, also die Anzahl kantone.

```{r, echo = TRUE}
n <- nrow(kantone_luftqual)
```


Im nenner dieses ersten Bruches müssen wir zuerst den Teil nach dem Summenzeichen lösen: $y_i -\bar{y}$. Dies heisst lediglich, das von jedem Wert den Mittwert aller Werte abziehen müssen.

```{r, echo = TRUE}
# Die Werte aller Kantone:
y <- kantone_luftqual$value

# Der Durchschnittswert aller Kantone
ybar <- mean(y, na.rm = TRUE)

# von jedem Wert den Durchschnittswert abziehen:
dy <- y - ybar
```

Das Summenzeichen sagt uns, dass wir `dy` zuerst quadrieren müssen, und danach die Summe der quadrierten Werte berechnen sollen.

```{r, echo = TRUE}
dy_sum <- sum(dy^2, na.rm = TRUE)
```



Um den ersten Bruch zu Lösen müssen wir nun noch die Anzahl werte durch `dy_sum` teilen.

```{r, echo = TRUE}
vr <- n/dy_sum
```

Hier nochmals zur Erinnerung, die ganze Formel. Wir wenden uns jetzt dem zweiten Bruch zu. Es hat hier jeweils zwei Summenzeichen mit unterschiedlichen laufvariablen ($i$ und $j$) und dem glechen Endwert $n$ (bei uns: Anzahl Kantone). Das bedeutet, dass wir alles nach den Summen zweichen *für alle Kombinationen* unserer Kantonalen Werte machen sollen. 
$$I = \frac{n}{\sum_{i=1}^n (y_i - \bar{y})^2} \times \frac{\sum_{i=1}^n \sum_{j=1}^n w_{ij}(y_i - \bar{y})(y_j - \bar{y})}{\sum_{i=1}^n \sum_{j=1}^n w_{ij}}$$
Der erste Begriff, $w_{ij}$, sind die räumlichen Gewichte aller Kantone. Sind die Kantone benachbart, dann gilt ein Gewicht von 1. Sind sie nicht benachbart, gilt ein Gewicht von 0.

Mit `st_touches()` wird für alle Kantone geprüft, welche Kantone sie berühren. Mit `sparse = FASE` wird eine Kreuzmatrix erstellt, was in unserem Fall sehr praktisch ist. 

```{r, echo = TRUE}
w <- st_touches(kantone_luftqual, sparse = FALSE)

w[1:6, 1:6]

# mit einer Multiplikation mit 1 Werden die TRUE Werte zu 1
# und die FALSE Werte zu 0
w <- w*1
w[1:6, 1:6]
```



Der nächste Teil,  $(y_i - \bar{y})$ kennen wir schon vom ersten Bruch und haben wir auch bereits gelöst. Diesmal müssen wir aber *das Produkt aller Wertekombinationen* berechnen (die doppelten Summenzeichen).


```{r, echo = TRUE}
pm <- tcrossprod(dy)
```

Nun multiplizieren wir die Werte mit den Gewichten $w$, damit wir nur noch die Werte von den Kantonen haben, die benachbart sind.

```{r, echo = TRUE}
pmw <- pm * w
pmw[1:6,1:6]
```

Den zähler des ersten Bruches haben wir errechnet, nachdem wir die Summe der gewichten Werten gebildet haben:
```{r, echo = TRUE}
spmw <- sum(pmw, na.rm = TRUE)
spmw
```

Für den Nenner des zweiten Bruches müssen wir nur noch die die Gewichte zu summieren:

```{r, echo = TRUE}
smw <- sum(w, na.rm = TRUE)
```

So können wir den zweiten Bruch auflösen:
```{r, echo = TRUE}
sw  <- spmw / smw
```


Und müssen nun nur noch die Resultate beider Brüche miteinander multiplizieren:


```{r, echo = TRUE}
MI <- vr * sw
MI

```





