[
  {
    "path": "prepro1/Demo_Datentypen/",
    "title": "Demo",
    "description": {},
    "author": [],
    "date": "2021-08-17",
    "categories": [],
    "contents": "\nDemo: Datentypen, Tabellen\nR-Code als Download\nDatentypen\nNumerics\nUnter die Kategorie numeric fallen in R zwei Datentypen:\ndouble: Gleitkommazahl (z.B. 10.3, 7.3)\ninteger: Ganzzahl (z.B. 10, 7)\nDoubles\nFolgendermassen wird eine Gleitkommazahl einer Variabel zuweisen:\n\n\nx <- 10.3\n\nx\n\n\n[1] 10.3\n\n\ntypeof(x)\n\n\n[1] \"double\"\n\nStatt <-kann auch = verwendet werden. Dies funktioniert aber nicht in allen Situationen, und ist zudem leicht mit == zu verwechseln.\n\n\ny = 7.3\n\ny\n\n\n[1] 7.3\n\nOhne explizite Zuweisung nimmt R immer den Datentyp doublean:\n\n\nz <- 42\ntypeof(z)\n\n\n[1] \"double\"\n\nis.integer(z)\n\n\n[1] FALSE\n\nis.numeric(z)\n\n\n[1] TRUE\n\nis.double(z)\n\n\n[1] TRUE\n\nGanzzahl / Integer\nErst wenn man eine Zahl explizit als integer definiert (mit as.integer() oder L), wird sie auch als solches abgespeichert.\n\n\na <- as.integer(z)\nis.numeric(a)\n\n\n[1] TRUE\n\nis.integer(a)\n\n\n[1] TRUE\n\n\nc <- 8L\nis.numeric(c)\n\n\n[1] TRUE\n\nis.integer(c)\n\n\n[1] TRUE\n\n\n\ntypeof(a)\n\n\n[1] \"integer\"\n\n\nis.numeric(a)\n\n\n[1] TRUE\n\nis.integer(a)\n\n\n[1] TRUE\n\nMit c() können eine Reihe von Werten in einer Variabel zugewiesen werden (als vector). Es gibt zudem auch character vectors.\n\n\nvector <- c(10,20,33,42,54,66,77)\nvector\n\n\n[1] 10 20 33 42 54 66 77\n\nvector[5]\n\n\n[1] 54\n\nvector[2:4]\n\n\n[1] 20 33 42\n\n\nvector2 <- vector[2:4]\n\n\n\nEine Ganzzahl kann explizit mit as.integer() definiert werden.\n\n\na <- as.integer(7)\nb <- as.integer(3.14)\na\n\n\n[1] 7\n\nb\n\n\n[1] 3\n\ntypeof(a)\n\n\n[1] \"integer\"\n\ntypeof(b)\n\n\n[1] \"integer\"\n\nis.integer(a)\n\n\n[1] TRUE\n\nis.integer(b)\n\n\n[1] TRUE\n\nEine Zeichenkette kann als Zahl eingelesen werden.\n\n\nc <- as.integer(\"3.14\")\nc\n\n\n[1] 3\n\ntypeof(c)\n\n\n[1] \"integer\"\n\nLogische Abfragen\nWird auch auch als boolesch (Eng. boolean) bezeichnet.\n\n\ne <- 3\nf <- 6\ng <- e > f\ne\n\n\n[1] 3\n\nf\n\n\n[1] 6\n\ng\n\n\n[1] FALSE\n\ntypeof(g)\n\n\n[1] \"logical\"\n\nLogische Operationen\n\n\nsonnig <- TRUE\ntrocken <- FALSE\n\nsonnig & !trocken\n\n\n[1] TRUE\n\nOft braucht man auch das Gegenteil / die Negation eines Wertes. Dies wird mittels ! erreicht\n\n\nu <- TRUE\nv <- !u \nv\n\n\n[1] FALSE\n\nZeichenketten\nZeichenketten (Eng. character) stellen Text dar\n\n\ns <- as.character(3.14)\ns\n\n\n[1] \"3.14\"\n\ntypeof(s)\n\n\n[1] \"character\"\n\nZeichenketten verbinden / zusammenfügen (Eng. concatenate)\n\n\nfname <- \"Hans\"\nlname <- \"Muster\"\npaste(fname,lname)\n\n\n[1] \"Hans Muster\"\n\n\nfname2 <- \"hans\"\nfname == fname2\n\n\n[1] FALSE\n\nFactors\nMit Factors wird in R eine Sammlung von Zeichenketten bezeichnet, die sich wiederholen, z.B. Wochentage (es gibt nur 7 unterschiedliche Werte für “Wochentage”).\n\n\nwochentage <- c(\"Montag\",\"Dienstag\",\"Mittwoch\",\"Donnerstag\",\"Freitag\",\"Samstag\",\"Sonntag\",\n                \"Montag\",\"Dienstag\",\"Mittwoch\",\"Donnerstag\",\"Freitag\",\"Samstag\",\"Sonntag\")\n\ntypeof(wochentage)\n\n\n[1] \"character\"\n\n\nwochentage_fac <- as.factor(wochentage)\n\nwochentage\n\n\n [1] \"Montag\"     \"Dienstag\"   \"Mittwoch\"   \"Donnerstag\" \"Freitag\"   \n [6] \"Samstag\"    \"Sonntag\"    \"Montag\"     \"Dienstag\"   \"Mittwoch\"  \n[11] \"Donnerstag\" \"Freitag\"    \"Samstag\"    \"Sonntag\"   \n\nwochentage_fac\n\n\n [1] Montag     Dienstag   Mittwoch   Donnerstag Freitag    Samstag   \n [7] Sonntag    Montag     Dienstag   Mittwoch   Donnerstag Freitag   \n[13] Samstag    Sonntag   \n7 Levels: Dienstag Donnerstag Freitag Mittwoch Montag ... Sonntag\n\nWie man oben sieht, unterscheiden sich character vectors und factors v.a. dadurch, dass letztere über sogenannte levels verfügt. Diese levels entsprechen den Eindeutigen (unique) Werten.\n\n\nlevels(wochentage_fac)\n\n\n[1] \"Dienstag\"   \"Donnerstag\" \"Freitag\"    \"Mittwoch\"   \"Montag\"    \n[6] \"Samstag\"    \"Sonntag\"   \n\n\nunique(wochentage)\n\n\n[1] \"Montag\"     \"Dienstag\"   \"Mittwoch\"   \"Donnerstag\" \"Freitag\"   \n[6] \"Samstag\"    \"Sonntag\"   \n\nZudem ist fällt auf, dass die Reihenfolge der Wohentag alphabetisch sortiert ist. Wie diese sortiert werden zeigen wir an einem anderen Beispiel:\n\n\nzahlen <- factor(c(\"null\",\"eins\",\"zwei\",\"drei\"))\n\nzahlen\n\n\n[1] null eins zwei drei\nLevels: drei eins null zwei\n\nOffensichtlich sollten diese factors geordnet sein, R weiss davon aber nichts. Eine Ordnung kann man mit dem Befehl ordered = T festlegen.\nBeachtet: ordered = T kann nur bei der Funktion factor() spezifiziert werden, nicht bei as.factor(). Ansonsten sind factor() und as.factor() sehr ähnlich.\n\n\nzahlen <- factor(zahlen,ordered = T)\n\nzahlen\n\n\n[1] null eins zwei drei\nLevels: drei < eins < null < zwei\n\nBeachtet das “<”-Zeichen zwischen den Levels. Die Zahlen werden nicht in der korrekten Reihenfolge, sondern Alphabetisch geordnet. Die richtige Reihenfolge kann man mit levels = festlegen.\n\n\nzahlen <- factor(zahlen,ordered = T,levels = c(\"null\",\"eins\",\"zwei\",\"drei\",\"vier\"))\n\nzahlen\n\n\n[1] null eins zwei drei\nLevels: null < eins < zwei < drei < vier\n\nWie auch schon erwähnt werden factors als character Vektor dargestellt, aber als Integers gespeichert. Das führt zu einem scheinbaren Wiederspruch wenn man den Datentyp auf unterschiedliche Weise abfragt.\n\n\ntypeof(zahlen)\n\n\n[1] \"integer\"\n\n\nis.integer(zahlen)\n\n\n[1] FALSE\n\nMit typeof() wird eben diese Form der Speicherung abgefragt und deshalb mit integer beantwortet. Da es sich aber nicht um einen eigentlichen Integer Vektor handelt, wird die Frage is.integer() mit FALSE beantwortet. Das ist etwas verwirrend, beruht aber darauf, dass die beiden Funktionen die Frage von unterschiedlichen Perspektiven beantworten. In diesem Fall schafft class() Klarheit:\n\n\nclass(zahlen)\n\n\n[1] \"ordered\" \"factor\" \n\nWirklich verwirrend wird es, wenn factors in numeric umgewandelt werden sollen.\n\n\nzahlen\n\n\n[1] null eins zwei drei\nLevels: null < eins < zwei < drei < vier\n\nas.integer(zahlen)\n\n\n[1] 1 2 3 4\n\nDas die Übersetzung der auf Deutsch ausgeschriebenen Nummern in nummerische Zahlen nicht funktionieren würde, war ja klar. Weniger klar ist es jedoch, wenn die factors bereits aus nummerischen Zahlen bestehen.\n\n\nzahlen2 <- factor(c(\"3\",\"2\",\"1\",\"0\"))\n\nas.integer(zahlen2)\n\n\n[1] 4 3 2 1\n\nIn diesem Fall müssen die factors erstmals in character umgewandelt werden.\n\n\nzahlen2 <- factor(c(\"3\",\"2\",\"1\",\"0\"))\n\nas.integer(as.character(zahlen2))\n\n\n[1] 3 2 1 0\n\nZeit/Datum\nUm in R mit Datum/Zeit Datentypen umzugehen, müssen sie als POSIXct eingelesen werden (es gibt alternativ noch POSIXlt, aber diese ignorieren wir mal). Anders als Beispielsweise bei Excel, sollten in R Datum und Uhrzeit immer in einer Spalte gespeichert werden.\n\n\ndatum <- \"2017-10-01 13:45:10\"\n\nas.POSIXct(datum)\n\n\n[1] \"2017-10-01 13:45:10 CEST\"\n\nWenn das die Zeichenkette in dem obigen Format (Jahr-Monat-Tag Stunde:Minute:Sekunde) daher kommt, braucht as.POSIXctkeine weiteren Informationen. Sollte das Format von dem aber Abweichen, muss man der Funktion das genaue Schema jedoch mitteilen. Der Syntax dafür kann via ?strptime nachgeschlagen werden.\n\n\ndatum <- \"01.10.2017 13:45\"\n\nas.POSIXct(datum,format = \"%d.%m.%Y %H:%M\")\n\n\n[1] \"2017-10-01 13:45:00 CEST\"\n\n\ndatum <- as.POSIXct(datum,format = \"%d.%m.%Y %H:%M\")\n\n\n\nBeachtet, dass in den den obigen Beispiel R automatisch eine Zeitzone angenommen hat (CEST). R geht davon aus, dass die Zeitzone der System Timezone (Sys.timezone()) entspricht.\n\n\n\nstrftime(datum, format = \"%m\")\n\n\n[1] \"10\"\n\nstrftime(datum, format = \"%b\")\n\n\n[1] \"Okt\"\n\nstrftime(datum, format = \"%B\")\n\n\n[1] \"Oktober\"\n\nData Frames und Conveniance Variabeln\nEine data.frame ist die gängigste Art, Tabellarische Daten zu speichern.\n\n\ndf <- data.frame(\n  Stadt = c(\"Zürich\",\"Genf\",\"Basel\",\"Bern\",\"Lausanne\"),\n  Einwohner = c(396027,194565,175131,140634,135629),\n  Ankunft = c(\"1.1.2017 10:00\",\"1.1.2017 14:00\",\n              \"1.1.2017 13:00\",\"1.1.2017 18:00\",\"1.1.2017 21:00\")\n)\n\nstr(df)\n\n\n'data.frame':   5 obs. of  3 variables:\n $ Stadt    : chr  \"Zürich\" \"Genf\" \"Basel\" \"Bern\" ...\n $ Einwohner: num  396027 194565 175131 140634 135629\n $ Ankunft  : chr  \"1.1.2017 10:00\" \"1.1.2017 14:00\" \"1.1.2017 13:00\" \"1.1.2017 18:00\" ...\n\nIn der obigen data.frame wurde die Spalte Einwohner als Fliesskommazahl abgespeichert. Dies ist zwar nicht tragisch, aber da wir wissen das es sich hier sicher um Ganzzahlen handelt, können wir das korrigieren. Wichtiger ist aber, dass wir die Ankunftszeit (SpalteAnkunft) von einem Factor in ein Zeitformat (POSIXct) umwandeln.\n\n\ndf$Einwohner <- as.integer(df$Einwohner)\n\ndf$Einwohner\n\n\n[1] 396027 194565 175131 140634 135629\n\n\ndf$Ankunft <- as.POSIXct(df$Ankunft, format = \"%d.%m.%Y %H:%M\")\n\ndf$Ankunft\n\n\n[1] \"2017-01-01 10:00:00 CET\" \"2017-01-01 14:00:00 CET\"\n[3] \"2017-01-01 13:00:00 CET\" \"2017-01-01 18:00:00 CET\"\n[5] \"2017-01-01 21:00:00 CET\"\n\nDiese Rohdaten können nun helfen, um Hilfsvariablen (convenience variables) zu erstellen. Z.B. können wir die Städte einteilen in gross, mittel und klein.\n\n\ndf$Groesse[df$Einwohner > 300000] <- \"gross\"\ndf$Groesse[df$Einwohner <= 300000 & df$Einwohner > 150000] <- \"mittel\"\ndf$Groesse[df$Einwohner <= 150000] <- \"klein\"\n\n\n\nOder aber, die Ankunftszeit kann von der Spalte Ankunftabgeleitet werden. Dazu brauchen wir aber das Package lubridate\n\n\nlibrary(lubridate)\n\n\n\n\n\ndf$Ankunft_stunde <- hour(df$Ankunft)\n\n\n\nQuellen\n\n\n\n\n",
    "preview": {},
    "last_modified": "2021-08-17T17:55:06+02:00",
    "input_file": {}
  },
  {
    "path": "prepro1/Uebung_A/",
    "title": "Uebung",
    "description": {},
    "author": [],
    "date": "2021-08-17",
    "categories": [],
    "contents": "\nUebung A\nArbeiten mit RStudio “Project”\nWir empfehlen die Verwendung von “Projects” innerhalb von RStudio. RStudio legt für jedes Projekt dann einen Ordner an, in welches die Projekt-Datei abgelegt wird (Dateiendung .Rproj). Sollen innerhalb des Projekts dann R-Skripts geladen oder erzeugt werden, werden diese dann auch im angelegten Ordner abgelegt. Mehr zu RStudio Projects findet ihr hier.\nDas Verwenden von Projects bringt verschiedene Vorteile, wie zum Beispiel:\nFestlegen der Working Directory ohne die Verwendung des expliziten Pfades (setwd()). Das ist sinnvoll, da sich dieser Pfad ändern kann (Zusammenarbeit mit anderen Usern, Ausführung des Scripts zu einem späteren Zeitpunkt)\nAutomatisches Zwischenspeichern geöffneter Scripts und Wiederherstellung der geöffneten Scripts bei der nächsten Session\nFestlegen verschiedener projektspezifischer Optionen\nVerwendung von Versionsverwaltungssystemen (git oder SVN)\nArbeiten mit Libraries / Packages\nR ist ohne Zusatzpackete nicht mehr denkbar. Die allermeisten Packages werden auf CRAN gehostet und können leicht mittels install.packages() installiert werden. Eine sehr wichtige Sammlung von Packages wird von RStudio entwickelt. Unter dem Namen Tidyverse werden eine Reihe von Packages angeboten, den R-Alltag enorm erleichtert. Wir werden später näher auf das “Tidy”-Universum eingehen, an dieser Stelle können wir die Sammlung einfach mal installieren.\ninstall.packages(\"tidyverse\")\nUm ein package in R verwenden zu können, gibt es zwei Möglichkeiten:\nentweder man lädt es zu Beginn der R-session mittles library(tidyverse) (ohne Anführungs- und Schlusszeichen).\noder man ruft eine function mit vorangestelltem Packetname sowie zwei Doppelpunkten auf. dplyr::filter() ruft die Funktion filter() des Packets dplyr auf.\nLetztere Notation ist vor allem dann sinnvoll, wenn sich zwei unterschiedliche Funktionen mit dem gleichen namen in verschiedenen pacakges existieren. filter() existiert als Funktion einersits im package dplyr sowie in stats. Dieses Phänomen nennt man “masking”.\nZu beginn laden wir die nötigen Pakete:\n\n\n\n\nTidyverse liefert viele Funktionen, für die es in der normalen R-Umgebung (“base R”) keine wirkliche Alternative gibt. Andere Funktionen sind alternativen zu Base-R Funktionen:\ndata_frame() statt data.frame()\nread_* statt read.*\nparse_datetime statt as.POSIXct()\nDiese verhalten sich leicht anders als Base-R Funktionen: Sie treffen weniger Annahmen und sind etwas restriktiver. Wir verwenden oft Tidyverse Funktionen, ihr könnt aber selber entscheiden welche Version ihr benutzt.\nAufgabe 1\nErstelle eine data.frame mit nachstehenden Daten.\nTipps:\nEine leere data.frame zu erstellen ist schwieriger als wenn erstellen und befüllen der data.frame in einem Schritt erfolgt\nR ist dafür gedacht, Spalte für Spalte zu arbeiten (warum?), nicht Reihe für Reihe. Versuche dich an dieses Schema zu halten.\n\n\n\n\nTierart\nAnzahl\nGewicht\nGeschlecht\nBeschreibung\nFuchs\n2\n4.4\nm\nRötlich\nBär\n5\n40.3\nf\nBraun, gross\nHase\n1\n1.1\nm\nklein, mit langen Ohren\nElch\n3\n120.0\nm\nLange Beine, Schaufelgeweih\n\nAufgabe 2\nWas für Datentypen wurden (in Aufgabe 1) von R automatisch angenommen? Sind diese sinnvoll?\nTipp: Nutze dazu str()\n\n'data.frame':   4 obs. of  5 variables:\n $ Tierart     : chr  \"Fuchs\" \"Bär\" \"Hase\" \"Elch\"\n $ Anzahl      : num  2 5 1 3\n $ Gewicht     : num  4.4 40.3 1.1 120\n $ Geschlecht  : chr  \"m\" \"f\" \"m\" \"m\"\n $ Beschreibung: chr  \"Rötlich\" \"Braun, gross\" \"klein, mit langen Ohren\" \"Lange Beine, Schaufelgeweih\"\n\n\n[1] \"double\"\n\nAufgabe 3\nNutze die Spalte Gewicht um die Tiere in 3 Gewichtskategorien einzuteilen:\nleicht: < 5kg\nmittel: 5 - 100 kg\nschwer: > 100kg\n\n\n\n\nTierart\nAnzahl\nGewicht\nGeschlecht\nBeschreibung\nGewichtsklasse\nFuchs\n2\n4.4\nm\nRötlich\nleicht\nBär\n5\n40.3\nf\nBraun, gross\nmittel\nHase\n1\n1.1\nm\nklein, mit langen Ohren\nleicht\nElch\n3\n120.0\nm\nLange Beine, Schaufelgeweih\nschwer\n\nAufgabe 4\nImportiere den Datensatz order_52252_data.txt. Es handelt sich dabei um die stündlich gemittelten Temperaturdaten an verschiedenen Standorten in der Schweiz im Zeitraum 2000 - 2005. Wir empfehlen read_table()1 anstelle von read.table().\n\nError: '09_PrePro1/data/order_52252_data.txt' does not exist in current working directory ('/home/nils/temp/Unterrichtsunterlagen_HS20/_prepro1/Uebung_A').\n\n\nError in head(wetter, 10): object 'wetter' not found\n\nAufgabe 5\nSchau dir die Rückmeldung von read_table()an. Sind die Daten korrekt interpretiert worden?\n\n\n\nAufgabe 6\nDie Spalte time ist eine Datum/Zeitangabe im Format JJJJMMTTHH (siehe meta.txt). Damit R dies als Datum-/Zeitangabe erkennt, müssen wir die Spalte in einem R-Format (POSIXct) einlesen und dabei R mitteilen, wie sie aktuell formatiert ist. Lies die Spalte mit as.POSIXct() (oder parse_datetime) ein und spezifiziere sowohl format wie auch tz.\nTipps:\nWenn keine Zeitzone festgelegt wird, trifft as.POSIXct() eine Annahme (basierend auf Sys.timezone()). In unserem Fall handelt es sich aber um Werte in UTC (siehe meta.txt)\nas.POSIXcterwartet character: Wenn du eine Fehlermeldung hast die 'origin' must be supplied (o.ä) heisst, hast du der Funktion vermutlich einen Numeric übergeben.\n\nError in stopifnot(is.character(x)): object 'wetter' not found\nError in as.POSIXct(as.character(wetter$time), format = \"%Y%m%d%H\", tz = \"UTC\"): object 'wetter' not found\n\n\nError in head(wetter, 10): object 'wetter' not found\n\nAufgabe 7\nErstelle zwei neue Spalten mit Wochentag (Montag, Dienstag, etc) und Kalenderwoche. Verwende dazu die neu erstellte POSIXct-Spalte\n\nError in wday(wetter$time, label = T): object 'wetter' not found\nError in yday(x): object 'wetter' not found\n\n\nError in head(wetter, 10): object 'wetter' not found\n\nAufgabe 8\nErstelle eine neue Spalte basierend auf die Temperaturwerte mit der Einteilung “kalt” (Unter Null Grad) und “warm” (über Null Grad)\n\nError in wetter$temp_kat[wetter$tre200h0 > 0] <- \"warm\": object 'wetter' not found\nError in wetter$temp_kat[wetter$tre200h0 <= 0] <- \"kalt\": object 'wetter' not found\n\n\nError in head(wetter, 10): object 'wetter' not found\n\n\n@wickham2017, Kapitel 8 bzw. http://r4ds.had.co.nz/data-import.html)↩︎\n",
    "preview": {},
    "last_modified": "2021-08-17T18:01:17+02:00",
    "input_file": {}
  },
  {
    "path": "prepro1/Uebung_B/",
    "title": "knitr",
    "description": {},
    "author": [],
    "date": "2021-08-17",
    "categories": [],
    "contents": "\n\n\n\nUebung B\n\n\n\nFahre mit dem Datensatz wetter aus Übung A fort.\n\nError: '09_PrePro1/data/order_52252_data.txt' does not exist in current working directory ('/home/nils/temp/Unterrichtsunterlagen_HS20/_prepro1/Uebung_B').\n\nAufgabe 1\nNutze plot() um die Temparaturkurve zu visualisieren. Verwende aber vorher filter() um dich auf eine Station (z.B. “ABO”) zu beschränken (es handelt sich sonst um zuviele Datenpunkte).\n\nError in dplyr::filter(wetter, stn == \"ABO\"): object 'wetter' not found\nError in plot(wetter_fil$time, wetter_fil$tre200h0, type = \"l\"): object 'wetter_fil' not found\n\nNun schauen wir uns das plotten mit ggplot2 an. Ein simpler Plot wie der in der vorherigen Aufgabe ist in ggplot2 zugegebenermassen etwas komplizierter. ggplot2 wird aber rasch einfacher, wenn die Grafiken komplexer werden. Wir empfehlen deshalb stark, ggplot2 zu verwenden.\nSchau dir ein paar online Tutorials zu ggplot2 an (siehe 1) und reproduziere den obigen Plot mit ggplot2\n\n\n\np <- ggplot(wetter_fil, aes(time,tre200h0)) +\n  geom_line()\n\n\nError in ggplot(wetter_fil, aes(time, tre200h0)): object 'wetter_fil' not found\n\n\np\n\n\nError in eval(expr, envir, enclos): object 'p' not found\n\nAufgabe 2\nSpiele mit Hilfe der erwähnten Tutorials mit dem Plot etwas rum. Versuche die x-/y-Achsen zu beschriften sowie einen Titel hinzu zu fügen.\n\nError in eval(expr, envir, enclos): object 'p' not found\nError in eval(expr, envir, enclos): object 'p' not found\n\nAufgabe 3\nReduziere den x-Achsenausschnitt auf einen kleineren Zeitraum, beispielsweise einn beliebigen Monat. Verwende dazu lims() zusammen mit as.POSIXct() oder mache ein Subset von deinem Datensatz mit einer convenience-Variabel und filter().\n\nError in eval(expr, envir, enclos): object 'p' not found\n\n\n@wickham2017, Kapitel 1 bzw. http://r4ds.had.co.nz/data-visualisation.html oder hier ein sehr schönes Video: Learn R: An Introduction to ggplot2↩︎\n",
    "preview": {},
    "last_modified": "2021-08-17T18:16:31+02:00",
    "input_file": {}
  }
]
