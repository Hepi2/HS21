[
  {
    "path": "prepro/PrePro1_Demo_Datentypen/",
    "title": "Demo Datentypen",
    "description": {},
    "author": [
      {
        "name": "Patrick Laube",
        "url": {}
      },
      {
        "name": "Nils Ratnaweera",
        "url": {}
      },
      {
        "name": "Nikolaos Bakogiannis",
        "url": {}
      }
    ],
    "date": "2021-10-11",
    "categories": [
      "PrePro1"
    ],
    "contents": "\r\n\r\nContents\r\nDatentypen\r\nData Frames und Conveniance Variabeln\r\n\r\n\r\n\r\n\r\nR-Code als Download\r\nDatentypen\r\nNumerics\r\nUnter die Kategorie numeric fallen in R zwei Datentypen:\r\ndouble: Gleitkommazahl (z.B. 10.3, 7.3)\r\ninteger: Ganzzahl (z.B. 10, 7)\r\nDoubles\r\nFolgendermassen wird eine Gleitkommazahl einer Variabel zuweisen:\r\n\r\n\r\nx <- 10.3\r\n\r\nx\r\n\r\n\r\n[1] 10.3\r\n\r\ntypeof(x)\r\n\r\n\r\n[1] \"double\"\r\n\r\nStatt <-kann auch = verwendet werden. Dies funktioniert aber nicht in allen Situationen, und ist zudem leicht mit == zu verwechseln.\r\n\r\n\r\ny = 7.3\r\n\r\ny\r\n\r\n\r\n[1] 7.3\r\n\r\nOhne explizite Zuweisung nimmt R immer den Datentyp doublean:\r\n\r\n\r\nz <- 42\r\ntypeof(z)\r\n\r\n\r\n[1] \"double\"\r\n\r\nis.integer(z)\r\n\r\n\r\n[1] FALSE\r\n\r\nis.numeric(z)\r\n\r\n\r\n[1] TRUE\r\n\r\nis.double(z)\r\n\r\n\r\n[1] TRUE\r\n\r\nGanzzahl / Integer\r\nErst wenn man eine Zahl explizit als integer definiert (mit as.integer() oder L), wird sie auch als solches abgespeichert.\r\n\r\n\r\na <- as.integer(z)\r\nis.numeric(a)\r\n\r\n\r\n[1] TRUE\r\n\r\nis.integer(a)\r\n\r\n\r\n[1] TRUE\r\n\r\nc <- 8L\r\nis.numeric(c)\r\n\r\n\r\n[1] TRUE\r\n\r\nis.integer(c)\r\n\r\n\r\n[1] TRUE\r\n\r\n\r\n\r\ntypeof(a)\r\n\r\n\r\n[1] \"integer\"\r\n\r\nis.numeric(a)\r\n\r\n\r\n[1] TRUE\r\n\r\nis.integer(a)\r\n\r\n\r\n[1] TRUE\r\n\r\nMit c() können eine Reihe von Werten in einer Variabel zugewiesen werden (als vector). Es gibt zudem auch character vectors.\r\n\r\n\r\nvector <- c(10,20,33,42,54,66,77)\r\nvector\r\n\r\n\r\n[1] 10 20 33 42 54 66 77\r\n\r\nvector[5]\r\n\r\n\r\n[1] 54\r\n\r\nvector[2:4]\r\n\r\n\r\n[1] 20 33 42\r\n\r\nvector2 <- vector[2:4]\r\n\r\n\r\n\r\nEine Ganzzahl kann explizit mit as.integer() definiert werden.\r\n\r\n\r\na <- as.integer(7)\r\nb <- as.integer(3.14)\r\na\r\n\r\n\r\n[1] 7\r\n\r\nb\r\n\r\n\r\n[1] 3\r\n\r\ntypeof(a)\r\n\r\n\r\n[1] \"integer\"\r\n\r\ntypeof(b)\r\n\r\n\r\n[1] \"integer\"\r\n\r\nis.integer(a)\r\n\r\n\r\n[1] TRUE\r\n\r\nis.integer(b)\r\n\r\n\r\n[1] TRUE\r\n\r\nEine Zeichenkette kann als Zahl eingelesen werden.\r\n\r\n\r\nc <- as.integer(\"3.14\")\r\nc\r\n\r\n\r\n[1] 3\r\n\r\ntypeof(c)\r\n\r\n\r\n[1] \"integer\"\r\n\r\nLogische Abfragen\r\nWird auch auch als boolesch (Eng. boolean) bezeichnet.\r\n\r\n\r\ne <- 3\r\nf <- 6\r\ng <- e > f\r\ne\r\n\r\n\r\n[1] 3\r\n\r\nf\r\n\r\n\r\n[1] 6\r\n\r\ng\r\n\r\n\r\n[1] FALSE\r\n\r\ntypeof(g)\r\n\r\n\r\n[1] \"logical\"\r\n\r\nLogische Operationen\r\n\r\n\r\nsonnig <- TRUE\r\ntrocken <- FALSE\r\n\r\nsonnig & !trocken\r\n\r\n\r\n[1] TRUE\r\n\r\nOft braucht man auch das Gegenteil / die Negation eines Wertes. Dies wird mittels ! erreicht\r\n\r\n\r\nu <- TRUE\r\nv <- !u \r\nv\r\n\r\n\r\n[1] FALSE\r\n\r\nZeichenketten\r\nZeichenketten (Eng. character) stellen Text dar\r\n\r\n\r\ns <- as.character(3.14)\r\ns\r\n\r\n\r\n[1] \"3.14\"\r\n\r\ntypeof(s)\r\n\r\n\r\n[1] \"character\"\r\n\r\nZeichenketten verbinden / zusammenfügen (Eng. concatenate)\r\n\r\n\r\nfname <- \"Hans\"\r\nlname <- \"Muster\"\r\npaste(fname,lname)\r\n\r\n\r\n[1] \"Hans Muster\"\r\n\r\nfname2 <- \"hans\"\r\nfname == fname2\r\n\r\n\r\n[1] FALSE\r\n\r\nFactors\r\nMit Factors wird in R eine Sammlung von Zeichenketten bezeichnet, die sich wiederholen, z.B. Wochentage (es gibt nur 7 unterschiedliche Werte für “Wochentage”).\r\n\r\n\r\nwochentage <- c(\"Donnerstag\",\"Freitag\",\"Samstag\",\"Sonntag\",\"Montag\",\"Dienstag\",\"Mittwoch\",\r\n                \"Donnerstag\",\"Freitag\",\"Samstag\",\"Sonntag\", \"Montag\",\"Dienstag\",\"Mittwoch\")\r\n\r\ntypeof(wochentage)\r\n\r\n\r\n[1] \"character\"\r\n\r\nwochentage_fac <- as.factor(wochentage)\r\n\r\nwochentage\r\n\r\n\r\n [1] \"Donnerstag\" \"Freitag\"    \"Samstag\"    \"Sonntag\"    \"Montag\"    \r\n [6] \"Dienstag\"   \"Mittwoch\"   \"Donnerstag\" \"Freitag\"    \"Samstag\"   \r\n[11] \"Sonntag\"    \"Montag\"     \"Dienstag\"   \"Mittwoch\"  \r\n\r\nwochentage_fac\r\n\r\n\r\n [1] Donnerstag Freitag    Samstag    Sonntag    Montag     Dienstag  \r\n [7] Mittwoch   Donnerstag Freitag    Samstag    Sonntag    Montag    \r\n[13] Dienstag   Mittwoch  \r\n7 Levels: Dienstag Donnerstag Freitag Mittwoch Montag ... Sonntag\r\n\r\nWie man oben sieht, unterscheiden sich character vectors und factors v.a. dadurch, dass letztere über sogenannte levels verfügt. Diese levels entsprechen den Eindeutigen (unique) Werten.\r\n\r\n\r\nlevels(wochentage_fac)\r\n\r\n\r\n[1] \"Dienstag\"   \"Donnerstag\" \"Freitag\"    \"Mittwoch\"   \"Montag\"    \r\n[6] \"Samstag\"    \"Sonntag\"   \r\n\r\nunique(wochentage)\r\n\r\n\r\n[1] \"Donnerstag\" \"Freitag\"    \"Samstag\"    \"Sonntag\"    \"Montag\"    \r\n[6] \"Dienstag\"   \"Mittwoch\"  \r\n\r\nZudem ist fällt auf, dass die Reihenfolge der Wohentag alphabetisch sortiert ist. Wie diese sortiert werden zeigen wir an einem anderen Beispiel:\r\n\r\n\r\nzahlen <- factor(c(\"null\",\"eins\",\"zwei\",\"drei\"))\r\n\r\nzahlen\r\n\r\n\r\n[1] null eins zwei drei\r\nLevels: drei eins null zwei\r\n\r\nOffensichtlich sollten diese factors geordnet sein, R weiss davon aber nichts. Eine Ordnung kann man mit dem Befehl ordered = T festlegen.\r\nBeachtet: ordered = T kann nur bei der Funktion factor() spezifiziert werden, nicht bei as.factor(). Ansonsten sind factor() und as.factor() sehr ähnlich.\r\n\r\n\r\nzahlen <- factor(zahlen,ordered = TRUE)\r\n\r\nzahlen\r\n\r\n\r\n[1] null eins zwei drei\r\nLevels: drei < eins < null < zwei\r\n\r\nBeachtet das “<”-Zeichen zwischen den Levels. Die Zahlen werden nicht in der korrekten Reihenfolge, sondern Alphabetisch geordnet. Die richtige Reihenfolge kann man mit levels = festlegen.\r\n\r\n\r\nzahlen <- factor(zahlen,ordered = T,levels = c(\"null\",\"eins\",\"zwei\",\"drei\",\"vier\"))\r\n\r\nzahlen\r\n\r\n\r\n[1] null eins zwei drei\r\nLevels: null < eins < zwei < drei < vier\r\n\r\nWie auch schon erwähnt werden factors als character Vektor dargestellt, aber als Integers gespeichert. Das führt zu einem scheinbaren Wiederspruch wenn man den Datentyp auf unterschiedliche Weise abfragt.\r\n\r\n\r\ntypeof(zahlen)\r\n\r\n\r\n[1] \"integer\"\r\n\r\nis.integer(zahlen)\r\n\r\n\r\n[1] FALSE\r\n\r\nMit typeof() wird eben diese Form der Speicherung abgefragt und deshalb mit integer beantwortet. Da es sich aber nicht um einen eigentlichen Integer Vektor handelt, wird die Frage is.integer() mit FALSE beantwortet. Das ist etwas verwirrend, beruht aber darauf, dass die beiden Funktionen die Frage von unterschiedlichen Perspektiven beantworten. In diesem Fall schafft class() Klarheit:\r\n\r\n\r\nclass(zahlen)\r\n\r\n\r\n[1] \"ordered\" \"factor\" \r\n\r\nWirklich verwirrend wird es, wenn factors in numeric umgewandelt werden sollen.\r\n\r\n\r\nzahlen\r\n\r\n\r\n[1] null eins zwei drei\r\nLevels: null < eins < zwei < drei < vier\r\n\r\nas.integer(zahlen)\r\n\r\n\r\n[1] 1 2 3 4\r\n\r\nDas die Übersetzung der auf Deutsch ausgeschriebenen Nummern in nummerische Zahlen nicht funktionieren würde, war ja klar. Weniger klar ist es jedoch, wenn die factors bereits aus nummerischen Zahlen bestehen.\r\n\r\n\r\nzahlen2 <- factor(c(\"10\",\"20\"))\r\nas.integer(zahlen2)\r\n\r\n\r\n[1] 1 2\r\n\r\nIn diesem Fall müssen die factors erstmals in character umgewandelt werden.\r\n\r\n\r\nas.integer(as.character(zahlen2))\r\n\r\n\r\n[1] 10 20\r\n\r\nZeit/Datum\r\nUm in R mit Datum/Zeit Datentypen umzugehen, müssen sie als POSIXct eingelesen werden (es gibt alternativ noch POSIXlt, aber diese ignorieren wir mal). Anders als Beispielsweise bei Excel, sollten in R Datum und Uhrzeit immer in einer Spalte gespeichert werden.\r\n\r\n\r\ndatum <- \"2017-10-01 13:45:10\"\r\n\r\nas.POSIXct(datum)\r\n\r\n\r\n[1] \"2017-10-01 13:45:10 CEST\"\r\n\r\nWenn das die Zeichenkette in dem obigen Format (Jahr-Monat-Tag Stunde:Minute:Sekunde) daher kommt, braucht as.POSIXctkeine weiteren Informationen. Sollte das Format von dem aber Abweichen, muss man der Funktion das genaue Schema jedoch mitteilen. Der Syntax dafür kann via ?strptime nachgeschlagen werden.\r\n\r\n\r\ndatum <- \"01.10.2017 13:45\"\r\n\r\nas.POSIXct(datum,format = \"%d.%m.%Y %H:%M\")\r\n\r\n\r\n[1] \"2017-10-01 13:45:00 CEST\"\r\n\r\ndatum <- as.POSIXct(datum,format = \"%d.%m.%Y %H:%M\")\r\n\r\n\r\n\r\nBeachtet, dass in den den obigen Beispiel R automatisch eine Zeitzone angenommen hat (CEST). R geht davon aus, dass die Zeitzone der System Timezone (Sys.timezone()) entspricht.\r\n\r\n\r\nstrftime(datum, format = \"%m\")\r\n\r\n\r\n[1] \"10\"\r\n\r\nstrftime(datum, format = \"%b\")\r\n\r\n\r\n[1] \"Okt\"\r\n\r\nstrftime(datum, format = \"%B\")\r\n\r\n\r\n[1] \"Oktober\"\r\n\r\nData Frames und Conveniance Variabeln\r\nEine data.frame ist die gängigste Art, Tabellarische Daten zu speichern.\r\n\r\n\r\ndf <- data.frame(\r\n  Stadt = c(\"Zürich\",\"Genf\",\"Basel\",\"Bern\",\"Lausanne\"),\r\n  Einwohner = c(396027,194565,175131,140634,135629),\r\n  Ankunft = c(\"1.1.2017 10:00\",\"1.1.2017 14:00\",\r\n              \"1.1.2017 13:00\",\"1.1.2017 18:00\",\"1.1.2017 21:00\")\r\n)\r\n\r\nstr(df)\r\n\r\n\r\n'data.frame':   5 obs. of  3 variables:\r\n $ Stadt    : chr  \"Zürich\" \"Genf\" \"Basel\" \"Bern\" ...\r\n $ Einwohner: num  396027 194565 175131 140634 135629\r\n $ Ankunft  : chr  \"1.1.2017 10:00\" \"1.1.2017 14:00\" \"1.1.2017 13:00\" \"1.1.2017 18:00\" ...\r\n\r\nIn der obigen data.frame wurde die Spalte Einwohner als Fliesskommazahl abgespeichert. Dies ist zwar nicht tragisch, aber da wir wissen das es sich hier sicher um Ganzzahlen handelt, können wir das korrigieren. Wichtiger ist aber, dass wir die Ankunftszeit (SpalteAnkunft) von einem Factor in ein Zeitformat (POSIXct) umwandeln.\r\n\r\n\r\ndf$Einwohner <- as.integer(df$Einwohner)\r\n\r\ndf$Einwohner\r\n\r\n\r\n[1] 396027 194565 175131 140634 135629\r\n\r\ndf$Ankunft <- as.POSIXct(df$Ankunft, format = \"%d.%m.%Y %H:%M\")\r\n\r\ndf$Ankunft\r\n\r\n\r\n[1] \"2017-01-01 10:00:00 CET\" \"2017-01-01 14:00:00 CET\"\r\n[3] \"2017-01-01 13:00:00 CET\" \"2017-01-01 18:00:00 CET\"\r\n[5] \"2017-01-01 21:00:00 CET\"\r\n\r\nDiese Rohdaten können nun helfen, um Hilfsvariablen (convenience variables) zu erstellen. Z.B. können wir die Städte einteilen in gross, mittel und klein.\r\n\r\n\r\ndf$Groesse[df$Einwohner > 300000] <- \"gross\"\r\ndf$Groesse[df$Einwohner <= 300000 & df$Einwohner > 150000] <- \"mittel\"\r\ndf$Groesse[df$Einwohner <= 150000] <- \"klein\"\r\n\r\n\r\n\r\nOder aber, die Ankunftszeit kann von der Spalte Ankunftabgeleitet werden. Dazu brauchen wir aber das Package lubridate\r\n\r\n\r\nlibrary(lubridate)\r\n\r\n\r\n\r\n\r\n\r\ndf$Ankunft_stunde <- hour(df$Ankunft)\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "prepro/PrePro1_Demo_Datentypen/types.jpg",
    "last_modified": "2021-10-13T11:57:05+02:00",
    "input_file": {}
  },
  {
    "path": "prepro/PrePro1_Uebung/",
    "title": "Uebung",
    "description": {},
    "author": [
      {
        "name": "Patrick Laube",
        "url": {}
      },
      {
        "name": "Nils Ratnaweera",
        "url": {}
      },
      {
        "name": "Nikolaos Bakogiannis",
        "url": {}
      }
    ],
    "date": "2021-10-14",
    "categories": [
      "PrePro1"
    ],
<<<<<<< HEAD
    "contents": "\r\n\r\nContents\r\nArbeiten mit RStudio “Project”\r\nArbeiten mit Libraries / Packages\r\nAufgabe 1\r\nAufgabe 2\r\nAufgabe 3\r\nAufgabe 4\r\nAufgabe 5\r\nAufgabe 6\r\nAufgabe 7\r\nAufgabe 8\r\n\r\nArbeiten mit RStudio “Project”\r\nWir empfehlen die Verwendung von “Projects” innerhalb von RStudio. RStudio legt für jedes Projekt dann einen Ordner an, in welches die Projekt-Datei abgelegt wird (Dateiendung .Rproj). Sollen innerhalb des Projekts dann R-Skripts geladen oder erzeugt werden, werden diese dann auch im angelegten Ordner abgelegt. Mehr zu RStudio Projects findet ihr hier.\r\nDas Verwenden von Projects bringt verschiedene Vorteile, wie zum Beispiel:\r\nFestlegen der Working Directory ohne die Verwendung des expliziten Pfades (setwd()). Das ist sinnvoll, da sich dieser Pfad ändern kann (Zusammenarbeit mit anderen Usern, Ausführung des Scripts zu einem späteren Zeitpunkt)\r\nAutomatisches Zwischenspeichern geöffneter Scripts und Wiederherstellung der geöffneten Scripts bei der nächsten Session\r\nFestlegen verschiedener projektspezifischer Optionen\r\nVerwendung von Versionsverwaltungssystemen (git oder SVN)\r\nArbeiten mit Libraries / Packages\r\nR ist ohne Zusatzpackete nicht mehr denkbar. Die allermeisten Packages werden auf CRAN gehostet und können leicht mittels install.packages() installiert werden. Eine sehr wichtige Sammlung von Packages wird von RStudio entwickelt. Unter dem Namen Tidyverse werden eine Reihe von Packages angeboten, den R-Alltag enorm erleichtert. Wir werden später näher auf das “Tidy”-Universum eingehen, an dieser Stelle können wir die Sammlung einfach mal die wichtigsten Packages aus tidyverse installieren.\r\ninstall.packages(\"dplyr\")\r\ninstall.packages(\"tidyr\")\r\ninstall.packages(\"readr\")\r\ninstall.packages(\"lubridate\")\r\nUm ein package in R verwenden zu können, gibt es zwei Möglichkeiten:\r\nentweder man lädt es zu Beginn der R-session mittles library(tidyverse) (ohne Anführungs- und Schlusszeichen).\r\noder man ruft eine function mit vorangestelltem Packetname sowie zwei Doppelpunkten auf. dplyr::filter() ruft die Funktion filter() des Packets dplyr auf.\r\nLetztere Notation ist vor allem dann sinnvoll, wenn sich zwei unterschiedliche Funktionen mit dem gleichen namen in verschiedenen pacakges existieren. filter() existiert als Funktion einersits im package dplyr sowie in stats. Dieses Phänomen nennt man “masking”.\r\nZu Beginn laden wir die nötigen Pakete :\r\n\r\n\r\nlibrary(dplyr)\r\nlibrary(ggplot2)\r\nlibrary(readr)\r\nlibrary(lubridate)\r\n\r\n# Im Unterschied zu `install.packages()` werden bei `library()` keine Anführungs- \r\n# und Schlusszeichen gesetzt.\r\n\r\n\r\n\r\nDplyr liefert viele Funktionen, für die es in der normalen R-Umgebung (“base R”) keine wirkliche Alternative gibt. Andere Funktionen sind alternativen zu Base-R Funktionen (read_csv statt read.csv, read_delim statt read.delim.\r\nDiese verhalten sich leicht anders als Base-R Funktionen: Sie treffen weniger Annahmen und sind etwas konservativer. Wir verwenden oft Tidyverse Funktionen, ihr könnt aber selber entscheiden welche Version ihr benutzt.\r\nAufgabe 1\r\nErstelle eine data.frame mit nachstehenden Daten.\r\nTipps:\r\nEine leere data.frame zu erstellen ist schwieriger als wenn erstellen und befüllen der data.frame in einem Schritt erfolgt\r\nR ist dafür gedacht, Spalte für Spalte zu arbeiten (warum?), nicht Reihe für Reihe. Versuche dich an dieses Schema zu halten.\r\n\r\n\r\n\r\n\r\nTierart\r\nAnzahl\r\nGewicht\r\nGeschlecht\r\nBeschreibung\r\nFuchs\r\n2\r\n4.4\r\nm\r\nRötlich\r\nBär\r\n5\r\n40.3\r\nf\r\nBraun, gross\r\nHase\r\n1\r\n1.1\r\nm\r\nklein, mit langen Ohren\r\nElch\r\n3\r\n120.0\r\nm\r\nLange Beine, Schaufelgeweih\r\n\r\nAufgabe 2\r\nWas für Datentypen wurden (in Aufgabe 1) von R automatisch angenommen? Sind diese sinnvoll?\r\nTipp: Nutze dazu str()\r\n\r\n'data.frame':   4 obs. of  5 variables:\r\n $ Tierart     : chr  \"Fuchs\" \"Bär\" \"Hase\" \"Elch\"\r\n $ Anzahl      : num  2 5 1 3\r\n $ Gewicht     : num  4.4 40.3 1.1 120\r\n $ Geschlecht  : chr  \"m\" \"f\" \"m\" \"m\"\r\n $ Beschreibung: chr  \"Rötlich\" \"Braun, gross\" \"klein, mit langen Ohren\" \"Lange Beine, Schaufelgeweih\"\r\n\r\n\r\n[1] \"double\"\r\n\r\nAufgabe 3\r\nNutze die Spalte Gewicht um die Tiere in 3 Gewichtskategorien einzuteilen:\r\nleicht: < 5kg\r\nmittel: 5 - 100 kg\r\nschwer: > 100kg\r\n\r\n\r\n\r\n\r\nTierart\r\nAnzahl\r\nGewicht\r\nGeschlecht\r\nBeschreibung\r\nGewichtsklasse\r\nFuchs\r\n2\r\n4.4\r\nm\r\nRötlich\r\nleicht\r\nBär\r\n5\r\n40.3\r\nf\r\nBraun, gross\r\nmittel\r\nHase\r\n1\r\n1.1\r\nm\r\nklein, mit langen Ohren\r\nleicht\r\nElch\r\n3\r\n120.0\r\nm\r\nLange Beine, Schaufelgeweih\r\nschwer\r\n\r\nAufgabe 4\r\nImportiere den Datensatz weather.csv (Rechtsklick -> Speichern Unter). Es handelt sich dabei um die stündlich gemittelten Temperaturdaten an verschiedenen Standorten in der Schweiz. Wir empfehlen read_csv() anstelle von read.csv().\r\nAchtung! read_csv erwartet leicht andere inputs als read.csv, schaut euch die Hilfe dazu an (?read_csv).\r\n\r\n\r\n\r\n\r\nstn\r\ntime\r\ntre200h0\r\nABO\r\n2000010100\r\n-2.6\r\nABO\r\n2000010101\r\n-2.5\r\nABO\r\n2000010102\r\n-3.1\r\nABO\r\n2000010103\r\n-2.4\r\nABO\r\n2000010104\r\n-2.5\r\nABO\r\n2000010105\r\n-3.0\r\nABO\r\n2000010106\r\n-3.7\r\nABO\r\n2000010107\r\n-4.4\r\nABO\r\n2000010108\r\n-4.1\r\nABO\r\n2000010109\r\n-4.1\r\n\r\nAufgabe 5\r\nSchau dir die Rückmeldung von read_csv()an. Sind die Daten korrekt interpretiert worden?\r\n\r\n\r\n\r\nAufgabe 6\r\nDie Spalte time ist eine Datum/Zeitangabe im Format JJJJMMTTHH (siehe meta.txt). Damit R dies als Datum-/Zeitangabe erkennt, müssen wir die Spalte in einem R-Format (POSIXct) einlesen und dabei R mitteilen, wie sie aktuell formatiert ist. Lies die Spalte mit as.POSIXct() ein und spezifiziere sowohl format wie auch tz.\r\nTipps:\r\nWenn keine Zeitzone festgelegt wird, trifft as.POSIXct() eine Annahme (basierend auf Sys.timezone()). In unserem Fall handelt es sich aber um Werte in UTC (siehe metadata.csv)\r\nas.POSIXcterwartet character: Wenn du eine Fehlermeldung hast die 'origin' must be supplied (o.ä) heisst, hast du der Funktion vermutlich einen Numeric übergeben.\r\n\r\n\r\n\r\n\r\nTable 1: Die neue Tabelle sollte so aussehen\r\nstn\r\ntime\r\ntre200h0\r\nABO\r\n2000-01-01 00:00:00\r\n-2.6\r\nABO\r\n2000-01-01 01:00:00\r\n-2.5\r\nABO\r\n2000-01-01 02:00:00\r\n-3.1\r\nABO\r\n2000-01-01 03:00:00\r\n-2.4\r\nABO\r\n2000-01-01 04:00:00\r\n-2.5\r\nABO\r\n2000-01-01 05:00:00\r\n-3.0\r\nABO\r\n2000-01-01 06:00:00\r\n-3.7\r\nABO\r\n2000-01-01 07:00:00\r\n-4.4\r\nABO\r\n2000-01-01 08:00:00\r\n-4.1\r\nABO\r\n2000-01-01 09:00:00\r\n-4.1\r\n\r\nAufgabe 7\r\nErstelle zwei neue Spalten mit Wochentag (Montag, Dienstag, etc) und Kalenderwoche. Verwende dazu die neu erstellte POSIXct-Spalte\r\n\r\n\r\n\r\n\r\nstn\r\ntime\r\ntre200h0\r\nwochentag\r\nkw\r\nABO\r\n2000-01-01 00:00:00\r\n-2.6\r\nSa\r\n1\r\nABO\r\n2000-01-01 01:00:00\r\n-2.5\r\nSa\r\n1\r\nABO\r\n2000-01-01 02:00:00\r\n-3.1\r\nSa\r\n1\r\nABO\r\n2000-01-01 03:00:00\r\n-2.4\r\nSa\r\n1\r\nABO\r\n2000-01-01 04:00:00\r\n-2.5\r\nSa\r\n1\r\nABO\r\n2000-01-01 05:00:00\r\n-3.0\r\nSa\r\n1\r\nABO\r\n2000-01-01 06:00:00\r\n-3.7\r\nSa\r\n1\r\nABO\r\n2000-01-01 07:00:00\r\n-4.4\r\nSa\r\n1\r\nABO\r\n2000-01-01 08:00:00\r\n-4.1\r\nSa\r\n1\r\nABO\r\n2000-01-01 09:00:00\r\n-4.1\r\nSa\r\n1\r\n\r\nAufgabe 8\r\nErstelle eine neue Spalte basierend auf die Temperaturwerte mit der Einteilung “kalt” (Unter Null Grad) und “warm” (über Null Grad)\r\n\r\n\r\n\r\n\r\nstn\r\ntime\r\ntre200h0\r\nwochentag\r\nkw\r\ntemp_kat\r\nABO\r\n2000-01-01 00:00:00\r\n-2.6\r\nSa\r\n1\r\nkalt\r\nABO\r\n2000-01-01 01:00:00\r\n-2.5\r\nSa\r\n1\r\nkalt\r\nABO\r\n2000-01-01 02:00:00\r\n-3.1\r\nSa\r\n1\r\nkalt\r\nABO\r\n2000-01-01 03:00:00\r\n-2.4\r\nSa\r\n1\r\nkalt\r\nABO\r\n2000-01-01 04:00:00\r\n-2.5\r\nSa\r\n1\r\nkalt\r\nABO\r\n2000-01-01 05:00:00\r\n-3.0\r\nSa\r\n1\r\nkalt\r\nABO\r\n2000-01-01 06:00:00\r\n-3.7\r\nSa\r\n1\r\nkalt\r\nABO\r\n2000-01-01 07:00:00\r\n-4.4\r\nSa\r\n1\r\nkalt\r\nABO\r\n2000-01-01 08:00:00\r\n-4.1\r\nSa\r\n1\r\nkalt\r\nABO\r\n2000-01-01 09:00:00\r\n-4.1\r\nSa\r\n1\r\nkalt\r\n\r\n\r\n\r\n\r\n",
    "preview": "prepro/PrePro1_Uebung/preview.png",
    "last_modified": "2021-10-13T11:57:07+02:00",
=======
    "contents": "\n\nContents\nArbeiten mit RStudio “Project”\nArbeiten mit Libraries / Packages\nAufgabe 1\nAufgabe 2\nAufgabe 3\nAufgabe 4\nAufgabe 5\nAufgabe 6\nAufgabe 7\nAufgabe 8\nMusterlösung\n\nArbeiten mit RStudio “Project”\nWir empfehlen die Verwendung von “Projects” innerhalb von RStudio. RStudio legt für jedes Projekt dann einen Ordner an, in welches die Projekt-Datei abgelegt wird (Dateiendung .Rproj). Sollen innerhalb des Projekts dann R-Skripts geladen oder erzeugt werden, werden diese dann auch im angelegten Ordner abgelegt. Mehr zu RStudio Projects findet ihr hier.\nDas Verwenden von Projects bringt verschiedene Vorteile, wie zum Beispiel:\nFestlegen der Working Directory ohne die Verwendung des expliziten Pfades (setwd()). Das ist sinnvoll, da sich dieser Pfad ändern kann (Zusammenarbeit mit anderen Usern, Ausführung des Scripts zu einem späteren Zeitpunkt)\nAutomatisches Zwischenspeichern geöffneter Scripts und Wiederherstellung der geöffneten Scripts bei der nächsten Session\nFestlegen verschiedener projektspezifischer Optionen\nVerwendung von Versionsverwaltungssystemen (git oder SVN)\nArbeiten mit Libraries / Packages\nR ist ohne Zusatzpackete nicht mehr denkbar. Die allermeisten Packages werden auf CRAN gehostet und können leicht mittels install.packages() installiert werden. Eine sehr wichtige Sammlung von Packages wird von RStudio entwickelt. Unter dem Namen Tidyverse werden eine Reihe von Packages angeboten, den R-Alltag enorm erleichtert. Wir werden später näher auf das “Tidy”-Universum eingehen, an dieser Stelle können wir die Sammlung einfach mal die wichtigsten Packages aus tidyverse installieren (heute werden wir davon nur einen kleinen Teil benutzen).\ninstall.packages(\"dplyr\")\ninstall.packages(\"tidyr\")\ninstall.packages(\"readr\")\ninstall.packages(\"lubridate\")\nUm ein package in R verwenden zu können, gibt es zwei Möglichkeiten:\nentweder man lädt es zu Beginn der R-session mittles library(dplyr) (ohne Anführungs- und Schlusszeichen).\noder man ruft eine function mit vorangestelltem Packetname sowie zwei Doppelpunkten auf. dplyr::filter() ruft die Funktion filter() des Packets dplyr auf.\nLetztere Notation ist vor allem dann sinnvoll, wenn sich zwei unterschiedliche Funktionen mit dem gleichen namen in verschiedenen pacakges existieren. filter() existiert als Funktion einersits im package dplyr sowie in stats. Dieses Phänomen nennt man “masking”.\nZu Beginn laden wir die nötigen Pakete :\n\n\nlibrary(readr)\nlibrary(lubridate)\n\n# Im Unterschied zu install.packages() werden bei library()\n# keine Anführungs- und Schlusszeichen gesetzt.\n\n\n\ndplyr liefert viele Funktionen, für die es in der normalen R-Umgebung (“base R”) keine wirkliche Alternative gibt. Andere Funktionen sind alternativen zu Base-R Funktionen (read_csv statt read.csv, read_delim statt read.delim.\nDiese verhalten sich leicht anders als Base-R Funktionen: Sie treffen weniger Annahmen und sind etwas konservativer. Wir verwenden oft Tidyverse Funktionen, ihr könnt aber selber entscheiden welche Version ihr benutzt.\nAufgabe 1\nErstelle eine data.frame mit nachstehenden Daten.\nTipps:\nEine leere data.frame zu erstellen ist schwieriger als wenn erstellen und befüllen der data.frame in einem Schritt erfolgt\nR ist dafür gedacht, Spalte für Spalte zu arbeiten (warum?), nicht Reihe für Reihe. Versuche dich an dieses Schema zu halten.\n\n\n\n\nTierart\nAnzahl\nGewicht\nGeschlecht\nBeschreibung\nFuchs\n2\n4.4\nm\nRötlich\nBär\n5\n40.3\nf\nBraun, gross\nHase\n1\n1.1\nm\nklein, mit langen Ohren\nElch\n3\n120.0\nm\nLange Beine, Schaufelgeweih\n\nAufgabe 2\nWas für Datentypen wurden (in Aufgabe 1) von R automatisch angenommen? Sind diese sinnvoll?\n\n'data.frame':   4 obs. of  5 variables:\n $ Tierart     : chr  \"Fuchs\" \"Bär\" \"Hase\" \"Elch\"\n $ Anzahl      : num  2 5 1 3\n $ Gewicht     : num  4.4 40.3 1.1 120\n $ Geschlecht  : chr  \"m\" \"f\" \"m\" \"m\"\n $ Beschreibung: chr  \"Rötlich\" \"Braun, gross\" \"klein, mit langen Ohren\" \"Lange Beine, Schaufelgeweih\"\n[1] \"double\"\n\nAufgabe 3\nNutze die Spalte Gewicht um die Tiere in 3 Gewichtskategorien einzuteilen:\nleicht: < 5kg\nmittel: 5 - 100 kg\nschwer: > 100kg\n\n\n\nAufgabe 4\nImportiere den Datensatz weather.csv (Rechtsklick -> Speichern Unter). Es handelt sich dabei um die stündlich gemittelten Temperaturdaten an verschiedenen Standorten in der Schweiz. Wir empfehlen read_csv() anstelle von read.csv().\nAchtung! read_csv erwartet leicht andere inputs als read.csv, schaut euch die Hilfe dazu an (?read_csv).\n\n\n\n\n\n\n\nstn\ntime\ntre200h0\nABO\n2000010100\n-2.6\nABO\n2000010101\n-2.5\nABO\n2000010102\n-3.1\nABO\n2000010103\n-2.4\nABO\n2000010104\n-2.5\nABO\n2000010105\n-3.0\nABO\n2000010106\n-3.7\nABO\n2000010107\n-4.4\nABO\n2000010108\n-4.1\nABO\n2000010109\n-4.1\n\nAufgabe 5\nSchau dir die Rückmeldung von read_csv()an. Sind die Daten korrekt interpretiert worden?\n\n\n\nAufgabe 6\nDie Spalte time ist eine Datum/Zeitangabe im Format JJJJMMTTHH (siehe meta.txt). Damit R dies als Datum-/Zeitangabe erkennt, müssen wir die Spalte in einem R-Format (POSIXct) einlesen und dabei R mitteilen, wie sie aktuell formatiert ist. Lies die Spalte mit as.POSIXct() ein und spezifiziere sowohl format wie auch tz.\nTipps:\nWenn keine Zeitzone festgelegt wird, trifft as.POSIXct() eine Annahme (basierend auf Sys.timezone()). In unserem Fall handelt es sich aber um Werte in UTC (siehe metadata.csv)\nas.POSIXcterwartet character: Wenn du eine Fehlermeldung hast die 'origin' must be supplied (o.ä) heisst, hast du der Funktion vermutlich einen Numeric übergeben.\n\n\n\n\nTable 1: Die neue Tabelle sollte so aussehen\nstn\ntime\ntre200h0\nABO\n2000-01-01 00:00:00\n-2.6\nABO\n2000-01-01 01:00:00\n-2.5\nABO\n2000-01-01 02:00:00\n-3.1\nABO\n2000-01-01 03:00:00\n-2.4\nABO\n2000-01-01 04:00:00\n-2.5\nABO\n2000-01-01 05:00:00\n-3.0\nABO\n2000-01-01 06:00:00\n-3.7\nABO\n2000-01-01 07:00:00\n-4.4\nABO\n2000-01-01 08:00:00\n-4.1\nABO\n2000-01-01 09:00:00\n-4.1\n\nAufgabe 7\nErstelle zwei neue Spalten mit Wochentag (Montag, Dienstag, etc) und Kalenderwoche. Verwende dazu die neu erstellte POSIXct-Spalte\n\n\n\n\nstn\ntime\ntre200h0\nwochentag\nkw\nABO\n2000-01-01 00:00:00\n-2.6\nSa\n1\nABO\n2000-01-01 01:00:00\n-2.5\nSa\n1\nABO\n2000-01-01 02:00:00\n-3.1\nSa\n1\nABO\n2000-01-01 03:00:00\n-2.4\nSa\n1\nABO\n2000-01-01 04:00:00\n-2.5\nSa\n1\nABO\n2000-01-01 05:00:00\n-3.0\nSa\n1\nABO\n2000-01-01 06:00:00\n-3.7\nSa\n1\nABO\n2000-01-01 07:00:00\n-4.4\nSa\n1\nABO\n2000-01-01 08:00:00\n-4.1\nSa\n1\nABO\n2000-01-01 09:00:00\n-4.1\nSa\n1\n\nAufgabe 8\nErstelle eine neue Spalte basierend auf die Temperaturwerte mit der Einteilung “kalt” (unter Null Grad) und “warm” (über Null Grad)\n\n\n\n\nstn\ntime\ntre200h0\nwochentag\nkw\ntemp_kat\nABO\n2000-01-01 00:00:00\n-2.6\nSa\n1\nkalt\nABO\n2000-01-01 01:00:00\n-2.5\nSa\n1\nkalt\nABO\n2000-01-01 02:00:00\n-3.1\nSa\n1\nkalt\nABO\n2000-01-01 03:00:00\n-2.4\nSa\n1\nkalt\nABO\n2000-01-01 04:00:00\n-2.5\nSa\n1\nkalt\nABO\n2000-01-01 05:00:00\n-3.0\nSa\n1\nkalt\nABO\n2000-01-01 06:00:00\n-3.7\nSa\n1\nkalt\nABO\n2000-01-01 07:00:00\n-4.4\nSa\n1\nkalt\nABO\n2000-01-01 08:00:00\n-4.1\nSa\n1\nkalt\nABO\n2000-01-01 09:00:00\n-4.1\nSa\n1\nkalt\n\nMusterlösung\n\nMusterlösung\n\n\n\n\n",
    "preview": "prepro/PrePro1_Uebung/preview.png",
    "last_modified": "2021-10-14T08:27:18+02:00",
>>>>>>> 4d13e84fa80429673a2bf31bec0e99ccd3593b08
    "input_file": {},
    "preview_width": 1950,
    "preview_height": 1200
  },
  {
    "path": "prepro/PrePro2_Demo/",
    "title": "Demo",
    "description": {},
    "author": [
      {
        "name": "Patrick Laube",
        "url": {}
      },
      {
        "name": "Nils Ratnaweera",
        "url": {}
      },
      {
        "name": "Nikolaos Bakogiannis",
        "url": {}
      }
    ],
    "date": "2021-10-18",
    "categories": [
      "PrePro2"
    ],
    "contents": "\n\nContents\nPiping\nJoins\n\n\n\n\nR-Code als Download\nPiping\nGegeben ist ein character string (diary). Wir wollen aus diesem Text die Temperaturangabe aus dem String extrahieren und danach den Wert von Kelvin in Celsius nach der folgenden Formel umwandeln und zum Schluss den Mittelwert über all diese Werte berechnen.\n\\[°C = K - 273.15\\]\n\n\ndiary <- c(\n  \"The temperature is 310° Kelvin\",\n  \"The temperature is 322° Kelvin\",\n  \"The temperature is 410° Kelvin\"\n)\n\ndiary\n\n\n[1] \"The temperature is 310° Kelvin\" \"The temperature is 322° Kelvin\"\n[3] \"The temperature is 410° Kelvin\"\n\nDafür haben wir eine Hilfsfunktion subtrahieren, welche zwei Werte annimmt, den minuend und den subtrahend:\n\n\nsubtrahieren <- function(minuend, subtrahend){\n  minuend - subtrahend\n}\n\n\n\nZudem brauchen wir die Funktion substr(), welche aus einem character einen teil “raus schnipseln” kann.\n\n\n# Wenn die Buchstaben einzelne _Elemente_ eines Vektors wären, würden wir diese\n# folgendermassen subsetten:\n\ncharvec1 <- c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\")\ncharvec1[4:6]\n\n\n[1] \"d\" \"e\" \"f\"\n\n# Aber wenn diese in einem einzigen character gespeichert sind, brauchen wir substr:\ncharvec2 <- \"abcdefgh\"\nsubstr(charvec2, 4, 6)\n\n\n[1] \"def\"\n\nÜbersetzt in R-Code entsteht folgende Operation:\n\n\n# 1. Nimm diary\n# 2. Extrahiere auf jeder Zeile die Werte 20 bis 22\n# 3. Konvertiere \"character\" zu \"numeric\"\n# 4. Subtrahiere 273.15\n# 5. Berechne den Mittlwert\n\noutput <- mean(subtrahieren(as.numeric(substr(diary, 20, 22)),273.15))\n#                                             \\_1_/\n#                                      \\________2__________/\n#                           \\___________________3___________/\n#              \\________________________________4__________________/\n#         \\_____________________________________5____________________/\n\n\n\nDie ganze Operation liest sich etwas leichter, wenn diese sequentiell notiert wird:\n\n\ntemp <- substr(diary, 20, 22)       # 1, 2\ntemp <- as.numeric(temp)            # 3\ntemp <- subtrahieren(temp, 273.15)  # 4\noutput <- mean(temp)                # 5\n\n\n\nUmständlich ist dabei einfach, dass die Zwischenresultate immer abgespeichert und in der darauf folgenden Operation wieder abgerufen werden müssen. Hier kommt “piping” ins Spiel: Mit “piping” wird der Output der einen Funktion der erste Parameter der darauf folgenden Funktion.\n\n\nlibrary(magrittr)\n\ndiary %>%                            # 1\n  substr(20, 22) %>%                 # 2\n  as.numeric() %>%                   # 3 \n  subtrahieren(273.15) %>%           # 4\n  mean()                             # 5\n\n\n[1] 74.18333\n\nNoch ein Hinweis: die %>% Pipe Operation aus magrittr wurde in R so beliebt, dass in R 4.1 ein “base R pipe” eingeführt. Diese sieht folgendermassen aus:\n\n\ndiary |>                             # 1\n  substr(20, 22) |>                  # 2\n  as.numeric() |>                    # 3 \n  subtrahieren(273.15) |>            # 4\n  mean()                             # 5\n\n\n[1] 74.18333\n\nJoins\n\n\nstudierende <- data.frame(\n  Matrikel_Nr = c(100002, 100003, 200003),\n  Studi = c(\"Patrick\", \"Manuela\", \"Eva\"),\n  PLZ = c(8006, 8001, 8820)\n)\n\n \n\nstudierende\n\n\n  Matrikel_Nr   Studi  PLZ\n1      100002 Patrick 8006\n2      100003 Manuela 8001\n3      200003     Eva 8820\n\nortschaften <- data.frame(\n  PLZ = c(8003, 8006, 8810, 8820),\n  Ortsname = c(\"Zürich\", \"Zürich\", \"Horgen\", \"Wädenswil\")\n)\n\n \n\nortschaften\n\n\n   PLZ  Ortsname\n1 8003    Zürich\n2 8006    Zürich\n3 8810    Horgen\n4 8820 Wädenswil\n\nlibrary(dplyr)\n\ninner_join(studierende, ortschaften, by = \"PLZ\")\n\n\n  Matrikel_Nr   Studi  PLZ  Ortsname\n1      100002 Patrick 8006    Zürich\n2      200003     Eva 8820 Wädenswil\n\nleft_join(studierende, ortschaften, by = \"PLZ\")\n\n\n  Matrikel_Nr   Studi  PLZ  Ortsname\n1      100002 Patrick 8006    Zürich\n2      100003 Manuela 8001      <NA>\n3      200003     Eva 8820 Wädenswil\n\nright_join(studierende, ortschaften, by = \"PLZ\")\n\n\n  Matrikel_Nr   Studi  PLZ  Ortsname\n1      100002 Patrick 8006    Zürich\n2      200003     Eva 8820 Wädenswil\n3          NA    <NA> 8003    Zürich\n4          NA    <NA> 8810    Horgen\n\nfull_join(studierende, ortschaften, by = \"PLZ\")\n\n\n  Matrikel_Nr   Studi  PLZ  Ortsname\n1      100002 Patrick 8006    Zürich\n2      100003 Manuela 8001      <NA>\n3      200003     Eva 8820 Wädenswil\n4          NA    <NA> 8003    Zürich\n5          NA    <NA> 8810    Horgen\n\n\n\nstudierende <- data.frame(\n  Matrikel_Nr = c(100002, 100003, 200003),\n  Studi = c(\"Patrick\", \"Manuela\", \"Pascal\"),\n  Wohnort = c(8006, 8001, 8006)\n)\n \n\nleft_join(studierende, ortschaften, by = c(\"Wohnort\" = \"PLZ\"))\n\n\n  Matrikel_Nr   Studi Wohnort Ortsname\n1      100002 Patrick    8006   Zürich\n2      100003 Manuela    8001     <NA>\n3      200003  Pascal    8006   Zürich\n\n\n\n\n",
    "preview": "prepro/PrePro2_Demo/pipe.jpg",
    "last_modified": "2021-10-18T12:30:14+02:00",
    "input_file": {}
  },
  {
    "path": "prepro/PrePro2_Uebung_A/",
    "title": "Uebung A",
    "description": {},
    "author": [
      {
        "name": "Patrick Laube",
        "url": {}
      },
      {
        "name": "Nils Ratnaweera",
        "url": {}
      },
      {
        "name": "Nikolaos Bakogiannis",
        "url": {}
      }
    ],
    "date": "2021-10-18",
    "categories": [
      "PrePro2"
    ],
    "contents": "\n\nContents\nAufgabe 1\nAufgabe 2\nAufgabe 3\nAufgabe 4\nAufgabe 5\nAufgabe 6\nAufgabe 7\nMusterlösung\n\nFür die Musterlösungen werden wir die nachstehenden Libraries verwenden:\nAufgabe 1\nLade die Wetterdaten von letzer Woche runter (weather.csv) und importiere sie in R. Sorge dafür, dass die Spalten korrekt formatiert sind (stn als factor, time als POSIXct, tre200h0 als numeric.)\nAufgabe 2\nLade metadata herunter und lade es ebenfalls als csv ein.\nHinweis: Wenn Umlaute und Sonderzeichen nicht korrekt dargestellt werden (z.B. in Genève), hat das vermutlich mit der Zeichencodierung zu tun. Das File ist aktuell in ‘ANSI’ Codiert, welche für gewisse Betriebssysteme / R-Versionen ein Problem darstellt. Um das Problem zu umgehen muss man das File mit einem Editor öffnen (Windows ‘Editor’ oder ‘Notepad++’, Mac: ‘TextEdit’) und mit einer neuen Codierung (z.B ‘UTF-8’) abspeichern. Danach kann die Codierung spezifitiert werden (bei read_delim(): mitlocale = locale(encoding = “UTF-8”)`)\nAufgabe 3\nDie x-/y-Koordinaten sind aktuell in einer Spalte erfasst. Um mit den Koordinaten sinnvoll arbeiten zu können, brauchen wir die Koordinaten getrennt. Trenne die x und y Koordinaten aus der Spalte Koordinaten.\nSchritt: verwende stringr::str_split_fixed um die Spalte in eine matrix zu überführen\nSchritt: benenne die Spalten der matrix in x und y um\nSchritt: nutze cbind um die matrix mit der data.frame zu verbinden\nAufgabe 4\nNun wollen wir den Datensatz wettermit den Informationen aus metadata anreichern. Uns interessiert aber nur das Stationskürzel, der Name, die x/y Koordinaten sowie die Meereshöhe. Lösche die nicht benötigten Spalten (oder selektiere die benötigten Spalten).\nAufgabe 5\nNun ist der Datensatz metadata genügend vorbereitet. Jetzt kann er mit dem Datensatz wetter verbunden werden. Überlege dir, welcher Join dafür sinnvoll ist und mit welchem Attribut wir “joinen” können.\nNutze die Join-Möglichkeiten von dplyr (Hilfe via ?dplyr::join) um die Datensätze wetter und metadata zu verbinden.\nAufgabe 6\nErstelle eine neue Spalte month welche den jeweiligen Monat (aus time) beinhaltet. Nutze dafür die Funktion lubridate::month().\nAufgabe 7\nBerechne mit der Spalte month die Durchschnittstemperatur pro Monat.\nMusterlösung\n\nMusterlösung\n\n\n\n\n",
    "preview": "prepro/PrePro2_Uebung_A/weather.jpg",
    "last_modified": "2021-10-18T12:29:44+02:00",
    "input_file": {}
  },
  {
    "path": "prepro/PrePro2_Uebung_B/",
    "title": "Übung B",
    "description": {},
    "author": [
      {
        "name": "Patrick Laube",
        "url": {}
      },
      {
        "name": "Nils Ratnaweera",
        "url": {}
      },
      {
        "name": "Nikolaos Bakogiannis",
        "url": {}
      }
    ],
    "date": "2021-10-18",
    "categories": [
      "PrePro2"
    ],
<<<<<<< HEAD
    "contents": "\r\n\r\nContents\r\nPiping\r\nJoins\r\n\r\n\r\n\r\n\r\nR-Code als Download\r\nPiping\r\nGegeben ist ein character string (diary) sowie die Hilfsfunktion subtrahieren\r\nWir wollen aus diesem Text die Temperaturangabe aus dem String extrahieren und danach den Wert von Kelvin in Celsius nach der folgenden Formel umwandeln und zum schluss den Mittelwert über all diese Werte berechnen.\r\n\\[°C = K - 273.15\\]\r\n\r\n\r\ndiary <- c(\r\n  \"The temperature is 310° Kelvin\",\r\n  \"The temperature is 322° Kelvin\",\r\n  \"The temperature is 410° Kelvin\"\r\n)\r\n\r\ndiary\r\n\r\n\r\n[1] \"The temperature is 310° Kelvin\" \"The temperature is 322° Kelvin\"\r\n[3] \"The temperature is 410° Kelvin\"\r\n\r\n\r\n\r\nsubtrahieren <- function(minuend, subtrahend){\r\n  minuend - subtrahend\r\n}\r\n\r\n\r\n\r\nÜbersetzt in R-Code entsteht folgende Operation:\r\n\r\n\r\n# 1. Nimm diary\r\n# 2. Extrahiere auf jeder Zeile die Werte 20 bis 22\r\n# 3. Konvertiere \"character\" zu \"numeric\"\r\n# 4. Subtrahiere 273.15\r\n# 5. Berechne den Mittlwert\r\n\r\noutput <- mean(subtrahieren(as.numeric(substr(diary, 20, 22)),273.15))\r\n#                                             \\_1_/\r\n#                                      \\________2__________/\r\n#                           \\___________________3___________/\r\n#              \\________________________________4__________________/\r\n#         \\_____________________________________5____________________/\r\n\r\n\r\n\r\nDie ganze Operation liest sich etwas leichter, wenn diese sequentiell notiert wird:\r\n\r\n\r\ntemp <- substr(diary, 20, 22)       # 1, 2\r\ntemp <- as.numeric(temp)            # 3\r\ntemp <- subtrahieren(temp, 273.15)  # 4\r\noutput <- mean(temp)                # 5\r\n\r\n\r\n\r\nUmständlich ist dabei einfach, dass die Zwischenresultate immer abgespeichert und in der darauf folgenden Operation wieder abgerufen werden müssen. Hier kommt “piping” ins Spiel: Mit “piping” wird der Output der einen Funktion der erste Parameter der darauf folgenden Funktion.\r\n\r\n\r\nlibrary(magrittr)\r\n\r\ndiary %>%                            # 1\r\n  substr(20, 22) %>%                 # 2\r\n  as.numeric() %>%                   # 3 \r\n  subtrahieren(273.15) %>%           # 4\r\n  mean()                             # 5\r\n\r\n\r\n[1] 74.18333\r\n\r\nNoch ein Hinweis: die %>% Pipe Operation aus magrittr wurde in R so beliebt, dass in R 4.1 ein “base R pipe” eingeführt. Diese sieht folgendermassen aus:\r\n\r\n\r\ndiary |>                             # 1\r\n  substr(20, 22) |>                  # 2\r\n  as.numeric() |>                    # 3 \r\n  subtrahieren(273.15) |>            # 4\r\n  mean()                             # 5\r\n\r\n\r\n[1] 74.18333\r\n\r\nJoins\r\n\r\n\r\nstudierende <- data.frame(\r\n  Matrikel_Nr = c(100002, 100003, 200003),\r\n  Studi = c(\"Patrick\", \"Manuela\", \"Pascal\"),\r\n  PLZ = c(8006, 8820, 8006)\r\n)\r\n\r\nstudierende\r\n\r\n\r\n  Matrikel_Nr   Studi  PLZ\r\n1      100002 Patrick 8006\r\n2      100003 Manuela 8820\r\n3      200003  Pascal 8006\r\n\r\nortschaften <- data.frame(\r\n  PLZ = c(8001, 8006, 8810, 8820),\r\n  Ortsname = c(\"Zürich\", \"Zürich\", \"Horgen\", \"Wädenswil\")\r\n)\r\n\r\nortschaften\r\n\r\n\r\n   PLZ  Ortsname\r\n1 8001    Zürich\r\n2 8006    Zürich\r\n3 8810    Horgen\r\n4 8820 Wädenswil\r\n\r\n\r\n\r\nlibrary(dplyr)\r\n\r\ninner_join(studierende, ortschaften, by = \"PLZ\")\r\n\r\n\r\n  Matrikel_Nr   Studi  PLZ  Ortsname\r\n1      100002 Patrick 8006    Zürich\r\n2      100003 Manuela 8820 Wädenswil\r\n3      200003  Pascal 8006    Zürich\r\n\r\nleft_join(studierende, ortschaften, by = \"PLZ\")\r\n\r\n\r\n  Matrikel_Nr   Studi  PLZ  Ortsname\r\n1      100002 Patrick 8006    Zürich\r\n2      100003 Manuela 8820 Wädenswil\r\n3      200003  Pascal 8006    Zürich\r\n\r\nright_join(studierende, ortschaften, by = \"PLZ\")\r\n\r\n\r\n  Matrikel_Nr   Studi  PLZ  Ortsname\r\n1      100002 Patrick 8006    Zürich\r\n2      100003 Manuela 8820 Wädenswil\r\n3      200003  Pascal 8006    Zürich\r\n4          NA    <NA> 8001    Zürich\r\n5          NA    <NA> 8810    Horgen\r\n\r\nfull_join(studierende, ortschaften, by = \"PLZ\")\r\n\r\n\r\n  Matrikel_Nr   Studi  PLZ  Ortsname\r\n1      100002 Patrick 8006    Zürich\r\n2      100003 Manuela 8820 Wädenswil\r\n3      200003  Pascal 8006    Zürich\r\n4          NA    <NA> 8001    Zürich\r\n5          NA    <NA> 8810    Horgen\r\n\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2021-10-13T11:57:07+02:00",
=======
    "contents": "\n\nContents\nAufgabe 1\nAufgabe 2\nAufgabe 3\nAufgabe 4\nMusterlösung\n\n\n\n\nAufgabe 1\nGegeben sind die Daten von drei Sensoren (sensor1.csv, sensor2.csv, sensor3.csv). Lade die Datensätze runter und lese sie ein.\n\n\n\n\n\n\nAufgabe 2\nErstelle aus den 3 Dataframes eine einzige Dataframe, die aussieht wie unten dargestellt. Nutze dafür zwei joins aus dplyr um 3 data.frames miteinander zu verbinden. Bereinige im Anschluss die Spaltennamen (wie geht das?).\n\n\n\n\nDatetime\nsensor1\nsensor2\nsensor3\n16102017_1800\n23.5\n13.5\n26.5\n17102017_1800\n25.4\n24.4\n24.4\n18102017_1800\n12.4\n22.4\n13.4\n19102017_1800\n5.4\n12.4\n7.4\n23102017_1800\n23.5\n13.5\nNA\n24102017_1800\n21.3\n11.3\nNA\n\nAufgabe 3\nImportiere die Datei sensor_1_fail.csv in R.\n\n\n\nsensor_fail.csv hat eine Variabel SensorStatus: 1 bedeutet der Sensor misst, 0 bedeutet der Sensor miss nicht. Fälschlicherweise wurde auch dann der Messwert Temp = 0 erfasst, wenn Sensorstatus = 0. Richtig wäre hier NA (not available). Korrigiere den Datensatz entsprechend.\n\nSensor\nTemp\nHumidity\nDatetime\nSensorStatus\nSen102\n0.6\n98\n16102017_1800\n1\nSen102\n0.3\n96\n17102017_1800\n1\nSen102\n0.0\n87\n18102017_1800\n1\nSen102\n0.0\n86\n19102017_1800\n0\nSen102\n0.0\n98\n23102017_1800\n0\nSen102\n0.0\n98\n24102017_1800\n0\nSen102\n0.0\n96\n25102017_1800\n1\nSen103\n-0.3\n87\n26102017_1800\n1\nSen103\n-0.7\n98\n27102017_1800\n1\nSen103\n-1.2\n98\n28102017_1800\n1\n\n\n\n\nAufgabe 4\nWarum spielt das es eine Rolle, ob 0 oder NA erfasst wird? Berechne die Mittlere der Temperatur / Feuchtigkeit nach der Korrektur.\n\n\n\nMusterlösung\n\nMusterlösung\n\n\n\n\n",
    "preview": "prepro/PrePro2_Uebung_B/sensor.jpg",
    "last_modified": "2021-10-18T12:29:52+02:00",
>>>>>>> 4d13e84fa80429673a2bf31bec0e99ccd3593b08
    "input_file": {}
  },
  {
    "path": "prepro/PrePro3_Demo_Split-Apply-Combine/",
    "title": "Demo tidyverse",
    "description": {},
    "author": [
      {
        "name": "Patrick Laube",
        "url": {}
      },
      {
        "name": "Nils Ratnaweera",
        "url": {}
      },
      {
        "name": "Nikolaos Bakogiannis",
        "url": {}
      }
    ],
    "date": "2021-10-13",
    "categories": [
      "PrePro3"
    ],
<<<<<<< HEAD
    "contents": "\r\n\r\nContents\r\nSplit-Apply-Combine\r\nPackete laden\r\nDaten Laden\r\nKennwerte berechnen\r\nConvenience Variablen\r\nKennwerte nach Gruppen berechnen\r\nVerketten vs. verschachteln\r\n\r\nReshaping data\r\nBreit -> lang\r\nLang -> breit\r\n\r\n\r\n\r\n\r\n\r\nDemoscript als Download\r\nHier möchten wir euch mit einer Sammlung von Tools vertraut machen, die spezifisch für das Daten prozessieren in Data Science entwickelt wurden. Der Prozess und das Modell ist hier1 schön beschrieben. Die Sammlung von Tools wird unter dem Namen tidyverse vertrieben. Die Tools erleichtern den Umgang mit Daten ungeheuer und haben sich mittlerweile zu einem “must have” im Umgang mit Daten in R entwickelt.\r\nWir können Euch nicht sämtliche Möglichkeiten von tidyverse zeigen. Wir fokussieren uns deshalb auf einzelne Komponenten2 und zeigen ein paar Funktionalitäten, die wir oft verwenden und Euch ggf. noch nicht bekannt sind. Wer sich vertieft mit dem Thema auseinandersetzen möchte, der sollte sich unbedingt das Buch @wickham2017 beschaffen. Eine umfangreiche, aber nicht ganz vollständige Version gibt es online3, das vollständige eBook kann über die Bibliothek bezogen werden4.\r\nSplit-Apply-Combine\r\nPackete laden\r\n\r\n\r\nlibrary(dplyr)\r\nlibrary(tidyr)\r\nlibrary(lubridate)\r\nlibrary(readr)\r\nlibrary(ggplot2)\r\n\r\n\r\n\r\nDaten Laden\r\nWir laden die Wetterdaten von der letzten Übung.\r\n\r\n\r\nwetter <- read_csv(\"https://github.com/ResearchMethods-ZHAW/datasets/raw/main/prepro/weather.csv\",\r\n                  col_types = list(\r\n                    col_factor(levels = NULL),    \r\n                    col_datetime(format = \"%Y%m%d%H\"),\r\n                    col_double()\r\n                    )\r\n                  )\r\n\r\n\r\n\r\nKennwerte berechnen\r\nWir möchten den Mittelwert aller gemessenen Temperaturwerte berechnen. Dazu könnten wir folgenden Befehl verwenden:\r\n\r\n\r\nmean(wetter$tre200h0, na.rm = TRUE) \r\n\r\n\r\n[1] 6.324744\r\n\r\nDie Option na.rm = T bedeutet, dass NA Werte von der Berechnung ausgeschlossen werden sollen.\r\nMit der selben Herangehensweise können diverse Werte berechnet werden (z.B. das Maximum (max()), Minimum (min()), Median (median()) u.v.m.).\r\nDiese Herangehensweise funktioniert nur dann gut, wenn wir die Kennwerte über alle Beobachtungen (Zeilen) für eine Variable (Spalte) berechnen wollen. Sobald wir die Beobachtungen gruppieren wollen, wird es schwierig. Zum Beispiel, wenn wir die durchschnittliche Temperatur pro Monat berechnen wollen.\r\nConvenience Variablen\r\nUm diese Aufgabe zu lösen, muss zuerst den Monat extrahiert werden (der Monat ist die convenience variabel). Hierfür brauchen wir die Funktion month() (von lubridate).\r\nNun kann kann die convenience Variable “Month” erstellt werden. Ohne dpylr wird eine neue Spalte wird folgendermassen hinzugefügt.\r\n\r\n\r\nwetter$month <- month(wetter$time)\r\n\r\n\r\n\r\nMit dplyr (siehe 5) sieht der gleiche Befehl folgendermassen aus:\r\n\r\n\r\nwetter <- mutate(wetter,month = month(time))\r\n\r\n\r\n\r\nDer grosse Vorteil von dplyr ist an dieser Stelle noch nicht ersichtlich. Dieser wird aber später klar.\r\nKennwerte nach Gruppen berechnen\r\nJetzt kann man die data.frame mithilfe der Spalte month filtern.\r\n\r\n\r\nmean(wetter$tre200h0[wetter$month == 1], na.rm = TRUE)\r\n\r\n\r\n[1] -1.963239\r\n\r\nDies müssen wir pro Monat wiederholen, was natürlich sehr umständlich ist. Deshalb nutzen wir das package dplyr. Damit geht die Aufgabe (Temperaturmittel pro Monat berechnen) folgendermassen:\r\n\r\n\r\nsummarise(group_by(wetter,month),temp_mittel = mean(tre200h0, na.rm = TRUE))\r\n\r\n\r\n# A tibble: 12 × 2\r\n   month temp_mittel\r\n   <dbl>       <dbl>\r\n 1     1      -1.96 \r\n 2     2       0.355\r\n 3     3       2.97 \r\n 4     4       4.20 \r\n 5     5      11.0  \r\n 6     6      12.4  \r\n 7     7      13.0  \r\n 8     8      15.0  \r\n 9     9       9.49 \r\n10    10       8.79 \r\n11    11       1.21 \r\n12    12      -0.898\r\n\r\nVerketten vs. verschachteln\r\nAuf Deutsch übersetzt heisst die obige Operation folgendermassen:\r\nnimm den Datensatz wetter\r\nBilde Gruppen pro Jahr (group_by(wetter,year))\r\nBerechne das Temperaturmittel (mean(tre200h0))\r\n\r\nDiese Übersetzung R-> Deutsch unterscheidet sich vor allem darin, dass die Operation auf Deutsch verkettet ausgesprochen wird (Operation 1->2->3) während der Computer verschachtelt liest 3(2(1)). Um R näher an die gesprochene Sprache zu bringen, kann man den %>%-Operator verwenden (siehe 6).\r\n\r\n\r\nsummarise(group_by(wetter,month),temp_mittel = mean(tre200h0))\r\n\r\n# wird zu:\r\n\r\nwetter %>%                                 #1) nimm den Datensatz \"wetter\"\r\n  group_by(month) %>%                      #2) Bilde Gruppen pro Jahr\r\n  summarise(temp_mittel = mean(tre200h0))  #3) berechne das Temperaturmittel \r\n\r\n\r\n\r\nDieses Verketten mittels %>% macht den Code einiges schreib- und leserfreundlicher, und wir werden ihn in den nachfolgenden Übungen verwenden. Dabei handelt es sich um das package magrittr, welches mit tidyverse mitgeliefert wird.\r\nZu dplyr und magrittrgibt es etliche Tutorials online (siehe7), deshalb werden wir diese Tools nicht in allen Details erläutern. Nur noch folgenden wichtigen Unterschied zu zwei wichtigen Funktionen in dpylr: mutate() und summarise().\r\nsummarise() fasst einen Datensatz zusammen. Dabei reduziert sich die Anzahl Beobachtungen (Zeilen) auf die Anzahl Gruppen (z.B. eine zusammengefasste Beobachtung (Zeile) pro Jahr). Zudem reduziert sich die Anzahl Variablen (Spalten) auf diejenigen, die in der “summarise” Funktion spezifiziert wurde (z.B. temp_mittel).\r\nmit mutate wird ein data.frame vom Umfang her belassen, es werden lediglich zusätzliche Variablen (Spalten) hinzugefügt (siehe Beispiel unten).\r\n\r\n\r\n# Maximal und minimal Temperatur pro Kalenderwoche\r\nweather_summary <- wetter %>%               #1) nimm den Datensatz \"wetter\"\r\n  filter(month == 1) %>%                    #2) filter auf den Monat Januar\r\n  mutate(day = day(time)) %>%               #3) erstelle eine neue Spalte \"day\"\r\n  group_by(day) %>%                         #4) Nutze die neue Spalte um Gruppen zu bilden\r\n  summarise(\r\n    temp_max = max(tre200h0, na.rm = TRUE), #5) Berechne das Maximum \r\n    temp_min = min(tre200h0, na.rm = TRUE)  #6) Berechne das Minimum\r\n    )   \r\n\r\nweather_summary\r\n\r\n\r\n# A tibble: 31 × 3\r\n     day temp_max temp_min\r\n   <int>    <dbl>    <dbl>\r\n 1     1      5.8     -4.4\r\n 2     2      2.8     -4.3\r\n 3     3      4.2     -3.1\r\n 4     4      4.7     -2.8\r\n 5     5     11.4     -0.6\r\n 6     6      6.7     -1.6\r\n 7     7      2.9     -2.8\r\n 8     8      0.2     -3.6\r\n 9     9      2.1     -8.8\r\n10    10      1.6     -2.4\r\n# … with 21 more rows\r\n\r\nReshaping data\r\nBreit -> lang\r\nDie Umformung von Tabellen breit->lang erfolgt mittels tidyr(siehe 8). Auch dieses package funktioniert wunderbar mit piping (%>%).\r\n\r\n\r\nweather_summary %>%\r\n  pivot_longer(c(temp_max,temp_min))\r\n\r\n\r\n# A tibble: 62 × 3\r\n     day name     value\r\n   <int> <chr>    <dbl>\r\n 1     1 temp_max   5.8\r\n 2     1 temp_min  -4.4\r\n 3     2 temp_max   2.8\r\n 4     2 temp_min  -4.3\r\n 5     3 temp_max   4.2\r\n 6     3 temp_min  -3.1\r\n 7     4 temp_max   4.7\r\n 8     4 temp_min  -2.8\r\n 9     5 temp_max  11.4\r\n10     5 temp_min  -0.6\r\n# … with 52 more rows\r\n\r\nIm Befehl pivot_longer() müssen wir festlegen, welche Spalten zusammengefasst werden sollen (hier: temp_max,temp_min,temp_mean). Alternativ können wir angeben, welche Spalten wir nicht zusammenfassen wollen:\r\n\r\n\r\nweather_summary %>%\r\n  pivot_longer(-day)\r\n\r\n\r\n# A tibble: 62 × 3\r\n     day name     value\r\n   <int> <chr>    <dbl>\r\n 1     1 temp_max   5.8\r\n 2     1 temp_min  -4.4\r\n 3     2 temp_max   2.8\r\n 4     2 temp_min  -4.3\r\n 5     3 temp_max   4.2\r\n 6     3 temp_min  -3.1\r\n 7     4 temp_max   4.7\r\n 8     4 temp_min  -2.8\r\n 9     5 temp_max  11.4\r\n10     5 temp_min  -0.6\r\n# … with 52 more rows\r\n\r\nWenn wir die Namen neuen Spalten festlegen wollen (anstelle von name und value) erreichen wir dies mit names_to bzw. values_to:\r\n\r\n\r\nweather_summary_long <- weather_summary %>%\r\n  pivot_longer(-day, names_to = \"Messtyp\", values_to = \"Messwert\")\r\n\r\n\r\n\r\nDie ersten 6 Zeilen von weather_summary_long:\r\n\r\nday\r\nMesstyp\r\nMesswert\r\n1\r\ntemp_max\r\n5.8\r\n1\r\ntemp_min\r\n-4.4\r\n2\r\ntemp_max\r\n2.8\r\n2\r\ntemp_min\r\n-4.3\r\n3\r\ntemp_max\r\n4.2\r\n3\r\ntemp_min\r\n-3.1\r\n\r\nDie ersten 6 Zeilen von wetter_sry:\r\n\r\nday\r\ntemp_max\r\ntemp_min\r\n1\r\n5.8\r\n-4.4\r\n2\r\n2.8\r\n-4.3\r\n3\r\n4.2\r\n-3.1\r\n4\r\n4.7\r\n-2.8\r\n5\r\n11.4\r\n-0.6\r\n6\r\n6.7\r\n-1.6\r\n\r\nBeachte: weather_summary_long umfasst 62 Beobachtungen (Zeilen), das sind doppelt soviel wie weather_summary, da wir ja zwei Spalten zusammengefasst haben.\r\n\r\n\r\nnrow(weather_summary)\r\n\r\n\r\n[1] 31\r\n\r\nnrow(weather_summary_long)\r\n\r\n\r\n[1] 62\r\n\r\n\r\n\r\nggplot(weather_summary_long, aes(day,Messwert, colour = Messtyp)) +\r\n  geom_line()\r\n\r\n\r\n\r\n\r\nLang -> breit\r\nDas Gegenstück zu pivot_longer ist pivot_wider. Mit dieser Funktion können wir eine lange Tabelle in eine breite überführen. Dazu müssen wir in names_from angeben, aus welcher Spalte die neuen Spaltennamen erstellt werden sollen (names_from) und aus welcher Spalte die Werte entstammen sollen (values_from):\r\n\r\n\r\nweather_summary_long %>%\r\n  pivot_wider(names_from = Messtyp, values_from = Messwert)\r\n\r\n\r\n# A tibble: 31 × 3\r\n     day temp_max temp_min\r\n   <int>    <dbl>    <dbl>\r\n 1     1      5.8     -4.4\r\n 2     2      2.8     -4.3\r\n 3     3      4.2     -3.1\r\n 4     4      4.7     -2.8\r\n 5     5     11.4     -0.6\r\n 6     6      6.7     -1.6\r\n 7     7      2.9     -2.8\r\n 8     8      0.2     -3.6\r\n 9     9      2.1     -8.8\r\n10    10      1.6     -2.4\r\n# … with 21 more rows\r\n\r\n\r\nhttp://r4ds.had.co.nz/introduction.html#↩︎\r\ndplyr, ggplot2, tidyr, magrittr, lubridate↩︎\r\nhttp://r4ds.had.co.nz/↩︎\r\nhttps://ebookcentral.proquest.com/lib/zhaw/detail.action?docID=4770093↩︎\r\n@wickham2017, Kapitel 10 / http://r4ds.had.co.nz/transform.html↩︎\r\n@wickham2017, Kapitel 14 / http://r4ds.had.co.nz/pipes.html↩︎\r\n@wickham2017, Kapitel 10 / http://r4ds.had.co.nz/transform.html, oder Hands-on dplyr tutorial..↩︎\r\nhttps://r4ds.had.co.nz/tidy-data.html#pivoting↩︎\r\n",
    "preview": "prepro/PrePro3_Demo_Tidyverse/distill-preview.png",
    "last_modified": "2021-10-13T11:57:05+02:00",
=======
    "contents": "\n\nContents\nSplit-Apply-Combine\nPackete laden\nDaten Laden\nKennwerte berechnen\nConvenience Variablen\nKennwerte nach Gruppen berechnen\nVerketten vs. verschachteln\n\nReshaping data\nBreit -> lang\nLang -> breit\n\n\n\n\n\nDemoscript als Download\nHier möchten wir euch mit einer Sammlung von Tools vertraut machen, die spezifisch für das Daten prozessieren in Data Science entwickelt wurden. Die Sammlung von Tools wird unter dem Namen tidyverse vertrieben. Die Tools erleichtern den Umgang mit Daten ungeheuer und haben sich mittlerweile zu einem “must have” im Umgang mit Daten in R entwickelt.\nWir können Euch nicht sämtliche Möglichkeiten von tidyverse zeigen. Wir fokussieren uns deshalb auf einzelne Komponenten1 und zeigen ein paar Funktionalitäten, die wir oft verwenden und Euch ggf. noch nicht bekannt sind. Wer sich vertieft mit dem Thema auseinandersetzen möchte, der sollte sich unbedingt das Buch Wickham and Grolemund (2017) beschaffen. Eine umfangreiche, aber nicht ganz vollständige Version gibt es online2, das vollständige eBook kann über die Bibliothek bezogen werden3.\nSplit-Apply-Combine\nPackete laden\n\n\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(lubridate)\nlibrary(readr)\nlibrary(ggplot2)\n\n\n\nDaten Laden\nWir laden die Wetterdaten von der letzten Übung.\n\n\n\n\n\nwetter <- read_csv(\"weather.csv\",\n                  col_types = list(\n                    col_factor(levels = NULL),    \n                    col_datetime(format = \"%Y%m%d%H\"),\n                    col_double()\n                    )\n                  )\n\n\n\nKennwerte berechnen\nWir möchten den Mittelwert aller gemessenen Temperaturwerte berechnen. Dazu könnten wir folgenden Befehl verwenden:\n\n\nmean(wetter$tre200h0, na.rm = TRUE) \n\n\n[1] 6.324744\n\nDie Option na.rm = T bedeutet, dass NA Werte von der Berechnung ausgeschlossen werden sollen.\nMit der selben Herangehensweise können diverse Werte berechnet werden (z.B. das Maximum (max()), Minimum (min()), Median (median()) u.v.m.).\nDiese Herangehensweise funktioniert nur dann gut, wenn wir die Kennwerte über alle Beobachtungen für eine Variable (Spalte) berechnen wollen. Sobald wir die Beobachtungen gruppieren wollen, wird es schwierig. Zum Beispiel, wenn wir die durchschnittliche Temperatur pro Monat berechnen wollen.\nConvenience Variablen\nUm diese Aufgabe zu lösen, muss zuerst den Monat extrahiert werden (der Monat ist die convenience variabel). Hierfür brauchen wir die Funktion lubridate::month().\nNun kann kann die convenience Variable “Month” erstellt werden. Ohne dpylr wird eine neue Spalte folgendermassen hinzugefügt.\n\n\nwetter$month <- month(wetter$time)\n\n\n\nMit dplyr (siehe)4 sieht der gleiche Befehl folgendermassen aus:\n\n\nwetter <- mutate(wetter,month = month(time))\n\n\n\nDer grosse Vorteil von dplyr ist an dieser Stelle noch nicht ersichtlich. Dieser wird aber später klar.\nKennwerte nach Gruppen berechnen\nUm mit base R den Mittelwert pro Monat zu berechnen, kann man zuerst ein Subset mit [] erstellen und davon den Mittelwerb berechnen, z.B. folgendermassen:\n\n\nmean(wetter$tre200h0[wetter$month == 1], na.rm = TRUE)\n\n\n[1] -1.963239\n\nDies müssen wir pro Monat wiederholen, was natürlich sehr umständlich ist. Deshalb nutzen wir das package dplyr. Damit geht die Aufgabe (Temperaturmittel pro Monat berechnen) folgendermassen:\n\n\nsummarise(group_by(wetter,month),temp_mittel = mean(tre200h0, na.rm = TRUE))\n\n\n# A tibble: 12 × 2\n   month temp_mittel\n   <dbl>       <dbl>\n 1     1      -1.96 \n 2     2       0.355\n 3     3       2.97 \n 4     4       4.20 \n 5     5      11.0  \n 6     6      12.4  \n 7     7      13.0  \n 8     8      15.0  \n 9     9       9.49 \n10    10       8.79 \n11    11       1.21 \n12    12      -0.898\n\nVerketten vs. verschachteln\nAuf Deutsch übersetzt heisst die obige Operation folgendermassen:\nnimm den Datensatz wetter\nBilde Gruppen pro Jahr (group_by(wetter,year))\nBerechne das Temperaturmittel (mean(tre200h0))\nDiese Übersetzung R-> Deutsch unterscheidet sich vor allem darin, dass die Operation auf Deutsch verkettet ausgesprochen wird (Operation 1->2->3) während der Computer verschachtelt liest 3(2(1)). Um R näher an die gesprochene Sprache zu bringen, kann man den %>%-Operator verwenden (siehe).5\n\n\n# 1 nimm den Datensatz \"wetter\"\n# 2 Bilde Gruppen pro Monat\n# 3 berechne das Temperaturmittel \n\nsummarise(group_by(wetter,month),temp_mittel = mean(tre200h0))\n#                  \\_1_/\n#         \\__________2_________/\n#\\___________________3_______________________________________/\n\n# wird zu:\n\nwetter %>%                                 # 1\n  group_by(month) %>%                      # 2\n  summarise(temp_mittel = mean(tre200h0))  # 3\n\n\n\nDieses Verketten mittels %>% (genannt “pipe”) macht den Code einiges schreib- und leserfreundlicher, und wir werden ihn in den nachfolgenden Übungen verwenden. Die “pipe” wird mit dem package magrittr bereitgestellt und mit dplyr mitinstalliert.\nZu dplyr gibt es etliche Tutorials online (siehe6), deshalb werden wir diese Tools nicht in allen Details erläutern. Nur noch folgenden wichtigen Unterschied zu zwei wichtigen Funktionen in dpylr: mutate() und summarise().\nsummarise() fasst einen Datensatz zusammen. Dabei reduziert sich die Anzahl Beobachtungen (Zeilen) auf die Anzahl Gruppen (z.B. eine zusammengefasste Beobachtung (Zeile) pro Jahr). Zudem reduziert sich die Anzahl Variablen (Spalten) auf diejenigen, die in der “summarise” Funktion spezifiziert wurde (z.B. temp_mittel).\nmit mutate wird ein data.frame vom Umfang her belassen, es werden lediglich zusätzliche Variablen (Spalten) hinzugefügt (siehe Beispiel unten).\n\n\n# Maximal und minimal Temperatur pro Kalenderwoche\nweather_summary <- wetter %>%               #1) nimm den Datensatz \"wetter\"\n  filter(month == 1) %>%                    #2) filter auf den Monat Januar\n  mutate(day = day(time)) %>%               #3) erstelle eine neue Spalte \"day\"\n  group_by(day) %>%                         #4) Nutze die neue Spalte um Gruppen zu bilden\n  summarise(\n    temp_max = max(tre200h0, na.rm = TRUE), #5) Berechne das Maximum \n    temp_min = min(tre200h0, na.rm = TRUE)  #6) Berechne das Minimum\n    )   \n\nweather_summary\n\n\n# A tibble: 31 × 3\n     day temp_max temp_min\n   <int>    <dbl>    <dbl>\n 1     1      5.8     -4.4\n 2     2      2.8     -4.3\n 3     3      4.2     -3.1\n 4     4      4.7     -2.8\n 5     5     11.4     -0.6\n 6     6      6.7     -1.6\n 7     7      2.9     -2.8\n 8     8      0.2     -3.6\n 9     9      2.1     -8.8\n10    10      1.6     -2.4\n# … with 21 more rows\n\nReshaping data\nBreit -> lang\nDie Umformung von Tabellen breit->lang erfolgt mittels tidyr(siehe).7 Auch dieses package funktioniert wunderbar mit piping (%>%).\n\n\nweather_summary %>%\n  pivot_longer(c(temp_max,temp_min))\n\n\n# A tibble: 62 × 3\n     day name     value\n   <int> <chr>    <dbl>\n 1     1 temp_max   5.8\n 2     1 temp_min  -4.4\n 3     2 temp_max   2.8\n 4     2 temp_min  -4.3\n 5     3 temp_max   4.2\n 6     3 temp_min  -3.1\n 7     4 temp_max   4.7\n 8     4 temp_min  -2.8\n 9     5 temp_max  11.4\n10     5 temp_min  -0.6\n# … with 52 more rows\n\nIm Befehl pivot_longer() müssen wir festlegen, welche Spalten zusammengefasst werden sollen (hier: temp_max,temp_min,temp_mean). Alternativ können wir angeben, welche Spalten wir nicht zusammenfassen wollen:\n\n\nweather_summary %>%\n  pivot_longer(-day)\n\n\n# A tibble: 62 × 3\n     day name     value\n   <int> <chr>    <dbl>\n 1     1 temp_max   5.8\n 2     1 temp_min  -4.4\n 3     2 temp_max   2.8\n 4     2 temp_min  -4.3\n 5     3 temp_max   4.2\n 6     3 temp_min  -3.1\n 7     4 temp_max   4.7\n 8     4 temp_min  -2.8\n 9     5 temp_max  11.4\n10     5 temp_min  -0.6\n# … with 52 more rows\n\nWenn wir die Namen neuen Spalten festlegen wollen (anstelle von name und value) erreichen wir dies mit names_to bzw. values_to:\n\n\nweather_summary_long <- weather_summary %>%\n  pivot_longer(-day, names_to = \"Messtyp\", values_to = \"Messwert\")\n\n\n\nDie ersten 6 Zeilen von weather_summary_long:\n\nday\nMesstyp\nMesswert\n1\ntemp_max\n5.8\n1\ntemp_min\n-4.4\n2\ntemp_max\n2.8\n2\ntemp_min\n-4.3\n3\ntemp_max\n4.2\n3\ntemp_min\n-3.1\n\nDie ersten 6 Zeilen von wetter_sry:\n\nday\ntemp_max\ntemp_min\n1\n5.8\n-4.4\n2\n2.8\n-4.3\n3\n4.2\n-3.1\n4\n4.7\n-2.8\n5\n11.4\n-0.6\n6\n6.7\n-1.6\n\nBeachte: weather_summary_long umfasst 62 Beobachtungen (Zeilen), das sind doppelt soviel wie weather_summary, da wir ja zwei Spalten zusammengefasst haben.\n\n\nnrow(weather_summary)\n\n\n[1] 31\n\nnrow(weather_summary_long)\n\n\n[1] 62\n\nLange Tabellen sind in verschiedenen Situationen praktischer. Beispielsweise ist das Visualisieren mittels ggplot2 (dieses Package werdet ihr im Block “InfoVis” kennenlernen) mit long tables wesentlich einfacher.\n\n\nggplot(weather_summary_long, aes(day,Messwert, colour = Messtyp)) +\n  geom_line()\n\n\n\n\nLang -> breit\nDas Gegenstück zu pivot_longer ist pivot_wider. Mit dieser Funktion können wir eine lange Tabelle in eine breite überführen. Dazu müssen wir in names_from angeben, aus welcher Spalte die neuen Spaltennamen erstellt werden sollen (names_from) und aus welcher Spalte die Werte entstammen sollen (values_from):\n\n\nweather_summary_long %>%\n  pivot_wider(names_from = Messtyp, values_from = Messwert)\n\n\n# A tibble: 31 × 3\n     day temp_max temp_min\n   <int>    <dbl>    <dbl>\n 1     1      5.8     -4.4\n 2     2      2.8     -4.3\n 3     3      4.2     -3.1\n 4     4      4.7     -2.8\n 5     5     11.4     -0.6\n 6     6      6.7     -1.6\n 7     7      2.9     -2.8\n 8     8      0.2     -3.6\n 9     9      2.1     -8.8\n10    10      1.6     -2.4\n# … with 21 more rows\n\n\n\n\nWickham, Hadley, and Garrett Grolemund. 2017. R for Data Science. O’Reilly. https://ebookcentral.proquest.com/lib/zhaw/detail.action?docID=4770093.\n\n\ndplyr, ggplot2, tidyr, magrittr, lubridate↩︎\nhttp://r4ds.had.co.nz/↩︎\nhttps://ebookcentral.proquest.com/lib/zhaw/detail.action?docID=4770093↩︎\nWickham and Grolemund (2017), Kapitel 10 / http://r4ds.had.co.nz/transform.html↩︎\nWickham and Grolemund (2017), Kapitel 14 / http://r4ds.had.co.nz/pipes.html↩︎\nWickham and Grolemund (2017), Kapitel 10 / http://r4ds.had.co.nz/transform.html, oder Hands-on dplyr tutorial..↩︎\nhttps://r4ds.had.co.nz/tidy-data.html#pivoting↩︎\n",
    "preview": "prepro/PrePro3_Demo_Split-Apply-Combine/distill-preview.png",
    "last_modified": "2021-10-13T21:08:10+02:00",
>>>>>>> 4d13e84fa80429673a2bf31bec0e99ccd3593b08
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  }
]
