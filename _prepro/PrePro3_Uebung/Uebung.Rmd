---
title: Uebung
output: distill::distill_article
categories:
- PrePro3
draft: true
author:
  - name: Patrick Laube
  - name: Nils Ratnaweera
  - name: Nikolaos Bakogiannis
---



## Aufgabe 1


Gegeben sei ein Datensatz "[sensors_combined.csv](https://github.com/ResearchMethods-ZHAW/datasets/raw/main/prepro/sensors_combined.csv)", mit den Temperaturwerten von drei verschiedenen Sensoren. Lade diesen Datensatz herunter,  importiere ihn als csv in R (als `sensors_combined`). 

Formatiere die `Datetime` Spalte in `POSIXct` um. Verwende dazu die Funktion `as.POSIXct` (lies mit `?strftime()` nochmal nach wie du das spezfische Format (die "Schablone") festlegen kannst.

```{r, echo = FALSE, purl = FALSE}
download.file("https://github.com/ResearchMethods-ZHAW/datasets/raw/main/prepro/sensors_combined.csv", "sensors_combined.csv")
```


```{r}
library(readr)

sensors_combined <- read_csv("sensors_combined.csv")

sensors_combined$Datetime <- as.POSIXct(sensors_combined$Datetime, format = "%d%m%Y_%H%M")
```


## Aufgabe 2

Überführe die Tabelle in ein *langes* Format (verwende dazu die Funktion `pivot_longer` aus `tidyr`) und speichere den output als `sensors_long`. 

Tipp: im Argument `cols` kannst du entweder die Spalten auflisten, die "pivotiert" werden sollen. Alternativ kannst du (mit vorangestelltem Minuszeichen, `-`) die Spalte, bezeichnen, die *nicht* pivotiert werden soll. Dazu musst du die Spalten weder mit Anführungs- und Schlusszeichen noch mit dem $-Zeichen versehen.

```{r}
library(tidyr)


# Variante 1 (Spalten abwählen)
pivot_longer(sensors_combined, -Datetime) 

# Variante 2 (Spalten anwählen)
sensors_long <- pivot_longer(sensors_combined, c(sensor1:sensor3))

```

## Aufgabe 3

Gruppiere `sensors_long` nach der neuen Spalte wo die Sensor-Information enthalten ist (default: `name`) mit `group_by` und berechne die mittlere Temperatur pro Sensor (`summarise`). Hinweis: Beide Funktionen sind Teil des Packages `dplyr`.

```{r}
library(dplyr)

sensors_long %>%
  group_by(name) %>%
  summarise(temp_mean = mean(value, na.rm = TRUE))
```

## Aufgabe 4

Erstelle für `sensors_long` eine neue *conveniance* Variabel `month` welche den Monat beinhaltet (Tipp: verwende dazu die Funktion `month` aus `lubridate`). Gruppiere nun nach `month` *und* Sensor und berechne die mittlere Temperatur. 

```{r}
library(lubridate)

sensors_long %>%
  mutate(month = month(Datetime)) %>%
  group_by(month, name) %>%
  summarise(temp_mean = mean(value, na.rm = TRUE))
```


## Aufgabe 5

Lade jetzt nochmal den Datensatz [wetter.csv](https://github.com/ResearchMethods-ZHAW/datasets/raw/main/prepro/weather.csv) herunter und importiere ihn als CSV mit den Korrekten Spaltentypen ()

```{r, echo = FALSE, purl = FALSE}
download.file("https://github.com/ResearchMethods-ZHAW/datasets/raw/main/prepro/weather.csv", "weather.csv")

```

```{r}
weather <- read_csv("weather.csv", col_types = cols(col_factor(), col_datetime("%Y%m%d%H"), col_double()))
```





## Aufgabe 3

Überführe die **lange** Tabelle über in eine breite. Dabei sollte jede Station eine eigene Spalte enthalten (`names_from`), gefüllt mit den Temperaturwerten (`values_from`).  Speichere diese Tabelle in einer neuen Variabel.

```{r}

# Lösung Aufgabe 3

wetter_wide <- pivot_wider(wetter, names_from = stn, values_from = tre200h0)

```

```{r, echo = TRUE}
# Hier ein Ausschnitt der df, wie es aussehen sollte:
wetter_wide[1:5, 1:7]
```


## Aufgabe 9

Nun wollen wir das Resultat aus Aufgabe 7 nutzen, um die Durchschnittstemperatur der Meereshöhe gegenüber zu stellen. Dummerweise ging das Attribut `Meereshoehe` bei der `summarise()` Operation verloren (da bei `summarise()` alle Spalten weg fallen, die **nicht** in `group_by()` definiert wurden). Um die Spalte `Meereshoehe` beizubehalten, muss sie also unter `group_by()` aufgelistet werden. 

Wiederhole Übung 7 und siehe zu, dass die Meereshöhe beibehalten wird. Stelle danach in einem Scatterplot (wenn möglich mit `ggplot()`) die Meereshöhe der Durchschnittstemperatur gegenüber.

```{r}
# Lösung Aufgabe 9

wetter_sry <- wetter %>%
  group_by(stn,Meereshoehe) %>%
  summarise(temp_mean = mean(tre200h0))

# Achtung: wenn mehrere Argumente in group_by() definiert werden führt das 
# üblicherweise zu Untergruppen. In unserem Fall hat jede Station nur EINE 
# Meereshöhe, deshalb wird die Zahl der Gruppen nicht erhöht.
```


```{r}
ggplot(wetter_sry, aes(temp_mean,Meereshoehe)) +
  geom_point()
```

