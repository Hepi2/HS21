---
title: Statistik
output: distill::distill_article
categories:
- Statistik_Konsolidierung2
- Statistik

---

```{r echo = FALSE}

```

```{r, include=FALSE, purl=F}

knitr::opts_chunk$set(echo = T, collapse=TRUE)
```

# Statistik Konsolidierung 2 (10.11.2020)

In Statistik Konsolidierung 2 bekommen die Studierenden eine Einführung in das Thema der Ordinationen, eine Technik der deskriptiven Statistik. Diese Methoden visualisiert die Strukturen in multivariaten Datensätzen via Dimensionsreduktion. Das Prinzip und die praktische Implementierung wird detailliert am Beispiel der Hauptkomponentenanalyse (PCA) erklärt. Danach folgen kurze Einführungen in weitere Ordinationstechniken für besondere Fälle, welche bestimmte Limitierungen der PCA überwinden, namentlich NMDS.

## Demo: Statistik Konsolidierung 2

*****

>Download [R-Skript](demoskript_ordinationen_v2.R)

*****

```{r Beispiel pca mtcars, message=FALSE}

# Research Methods Statistik-Vorlesung 2020
# Ordinationen 
# Gian-Andrea Egeler & J?rgen Dengler 

#einfaches beispiel: angelehnt an diesem post: https://www.datacamp.com/community/tutorials/pca-analysis-r

#ausgangslage: viel zusammenh?ngende variablen
#ziel: reduktion der variablen
#WICHTIG: mit wide-format arbeiten => das ist mit matrizen gemeint

# lade datei
d <- mtcars

# korrelationen
cor<- cor(mtcars[,c(1:7,10,11)])
cor[abs(cor)<.7] <- 0
cor

# pca
# achtung unterschiedliche messeinheiten, wichtig es muss noch einheitlich transfomiert werden
library(FactoMineR)
o.pca <- PCA(mtcars[,c(1:7,10,11)], scale.unit = TRUE) # entweder korrelations oder covarianzmatrix

# schaue output an
summary(o.pca) # generiert auch automatische plots


# plote das ganze
library(ggbiplot)
ggbiplot(o.pca,choices = c(1,2))

# nehme noch die autonamen hinzu
ggbiplot(o.pca, labels=rownames(mtcars), choices = c(1,2)) # + mytheme # choice gibt die axen an

```


```{r pca mtcars, message=FALSE}
#-------------------------

#Mit Beispieldaten aus Wildi (2013, 2017)
# library(dave)
library(labdsv)
library(dave) # lade package f?r Datensatz sveg
head(sveg)


#PCA-----------
#Deckungen Wurzeltransformiert, cor=T erzwingt Nutzung der Korrelationsmatrix
o.pca <- labdsv::pca(sveg^0.25,cor=T)
o.pca2 <- stats::prcomp(sveg^0.25)

#Koordinaten im Ordinationsraum => Y
head(o.pca$scores)
head(o.pca2$x)

#Korrelationen der Variablen mit den Ordinationsachsen
head(o.pca$loadings)
head(o.pca2$rotation)

#Erklaerte Varianz der Achsen (sdev ist die Wurzel daraus)
# früher gabs den Befehl summary()
# jetzt von hand: standardabweichung im quadrat/totale varianz * 100 (um prozentwerte zu bekommen)
E<-o.pca$sdev^2/o.pca$totdev*100
E[1:5] # erste fünf PCA


#PCA-Plot der Lage der Beobachtungen im Ordinationsraum
plot(o.pca$scores[,1],o.pca$scores[,2],type="n", asp=1, xlab="PC1", ylab="PC2")
points(o.pca$scores[,1],o.pca$scores[,2],pch=18)

plot(o.pca$scores[,1],o.pca$scores[,3],type="n", asp=1, xlab="PC1", ylab="PC3")
points(o.pca$scores[,1],o.pca$scores[,3],pch=18)

#Subjektive Auswahl von Arten zur Darstellung
sel.sp <- c(3,11,23,39,46,72,77,96, 101, 119)
snames <- names(sveg[ , sel.sp])
snames

#PCA-Plot der Korrelationen der Variablen (hier Arten) mit den Achsen (h)
x <- o.pca$loadings[,1]
y <- o.pca$loadings[,2]
plot(x,y,type="n",asp=1)
arrows(0,0,x[sel.sp],y[sel.sp],length=0.08)
text(x[sel.sp],y[sel.sp],snames,pos=1,cex=0.6)

# hier gehts noch zu weiteren Beispielen zu PCA's:
# https://stats.stackexchange.com/questions/102882/steps-done-in-factor-analysis-compared-to-steps-done-in-pca/102999#102999
# https://stats.stackexchange.com/questions/222/what-are-principal-component-scores
# https://stats.stackexchange.com/questions/102882/steps-done-in-factor-analysis-compared-to-steps-done-in-pca/102999#102999

```


```{r pca wildi}
# PCA ---------------------------------------------------------------------
# Beispiel1: Daten aus Wildi (2013)
#Idee von Ordinationen aus Wildi p. 73-74

if(!require(labdsv)){install.packages("labdsv")}
library(labdsv)

#Für Ordinationen benötigen wir Matrizen, nicht Data.frames
#Generieren von Daten
raw <- matrix(c(1,2,2.5,2.5,1,0.5,0,1,2,4,3,1), nrow=6)
colnames(raw) <- c("spec.1", "spec.2")
rownames(raw) <- c("r1","r2","r3","r4","r5","r6")
raw

#originale Daten im zweidimensionalen Raum
x1 <- raw[,1]
y1 <- raw[,2]
z <- c(rep(1:6))


#Plot Abhängigkeit der Arten vom Umweltgradienten
plot(c(x1, y1)~c(z,z), type="n", axes=T, bty="l", las=1, xlim=c(1,6), ylim=c(0,5),
     xlab="Umweltgradient",ylab="Deckung der Arten")
points(x1~z, pch=21, type="b")
points(y1~z, pch=16, type="b")

#zentrierte Daten
cent <- scale(raw, scale=F)
x2 <- cent[,1]
y2 <- cent[,2]

#rotierte Daten
o.pca <- pca(raw)
x3 <- o.pca$scores[,1]
y3 <- o.pca$scores[,2]


#Visualisierung der Schritte im Ordinationsraum
plot(c(y1,y2,y3)~c(x1,x2,x3), type="n", axes=T, bty="l", las=1, xlim=c(-4,4), 
     ylim=c(-4,4), xlab="Art 1", ylab="Art 2")
points(y1~x1, pch=21, type="b", col="green", lwd=2)
points(y2~x2, pch=16, type="b",col="red", lwd=2)
points(y3~x3, pch=17, type="b", col="blue", lwd=2)

#Durchführung der PCA
pca <- pca(raw)

#Koordinaten im Ordinationsraum
pca$scores

#Korrelationen der Variablen mit den Ordinationsachsen
pca$loadings

#Erklärte Varianz der Achsen in Prozent
E <- pca$sdev^2/pca$totdev*100
E

#mit prcomp
pca.2 <- prcomp(raw, scale=F)
summary(pca.2)
plot(pca.2)
biplot(pca.2)

#mit vegan
if(!require(vegan)){install.packages("vegan")}
library("vegan")
pca.3 <- rda(raw, scale=FALSE) #Die Funktion rda führt ein PCA aus an wenn nicht Umwelt und Artdaten definiert werden
#scores(pca.3,display=c("sites"))
#scores(pca.3,display=c("species"))
summary(pca.3, axes=0)
biplot(pca.3, scaling=2)
biplot(pca.3, scaling="species")#scaling=species macht das selbe wie scaling=2


####Beispiel2: Daten aus Wildi 2013
if(!require(dave)){install.packages("dave")}
library(dave)
data(sveg)
str(sveg)
summary(sveg)
names(sveg)

#PCA: Deckungen Wurzeltransformiert, cor=T erzwingt Nutzung der Korrelationsmatrix
pca.5 <- pca(sveg^0.25,cor=T)

#Koordinaten im Ordinationsraum
pca.5$scores

#Korrelationen der Variablen mit den Ordinationsachsen
pca.5$loadings

#Erklärte Varianz der Achsen in Prozent (sdev ist die Wurzel daraus)
E<-pca.5$sdev^2/pca.5$totdev*100
E
E[1:5]

#PCA-Plot der Lage der Beobachtungen im Ordinationsraum
plot(pca.5$scores[,1], pca.5$scores[,2], type="n", asp=1, xlab="PC1", ylab="PC2")
points(pca.5$scores[,1], pca.5$scores[,2], pch=18)

#Subjektive Auswahl von Arten zur Darstellung
sel.sp <- c(3,11,23,39,46,72,77,96)
snames <- names(sveg[,sel.sp])
snames

#PCA-Plot der Korrelationen der Variablen (hier Arten) mit den Achsen (h)
x <- pca.5$loadings[,1]
y <- pca.5$loadings[,2]
plot(x,y,type="n", asp=1)
arrows(0,0, x[sel.sp], y[sel.sp], length=0.08)
text(x[sel.sp], y[sel.sp], snames,pos=1, cex=0.6)


# Mit vegan
pca.6 <- rda(sveg^0.25, scale=TRUE)
#Erklärte Varianz der Achsen
summary(pca.6, axes=0)
#PCA-Plot der Lage der Beobachtungen im Ordinationsraum
biplot(pca.6, display = "sites", type = "points", scaling=1)
#Subjektive Auswahl von Arten zur Darstellung
sel.sp <- c(3,11,23,39,46,72,77,96)
snames <- names(sveg[,sel.sp])
snames
#PCA-Plot der Korrelationen der Variablen (hier Arten) mit den Achsen (h)
scores <- scores(pca.6, display="species")
x <- scores[,1]
y <- scores[,2]
plot(x, y, type="n", asp=1)
arrows(0,0, x[sel.sp], y[sel.sp], length=0.08)
text(x[sel.sp], y[sel.sp], snames,pos=1,cex=0.6)
plot(x, y, type="n", asp=1, xlim=c(-1, 1), ylim=c(-0.6, 0.6)) # angepasste Achsen
```



```{r CA, message=FALSE}
#CA---------

library(vegan)
library(FactoMineR) # siehe Beispiel hier: https://www.youtube.com/watch?v=vP4korRby0Q

# ebenfalls mit transformierten daten
o.ca<-cca(sveg^0.5)
o.ca1 <- CA(sveg^0.5)

#Arten (o) und Communities (+) plotten
plot(o.ca)

summary(o.ca1)
plot(o.ca1)

#Nur Arten plotten
x<-o.ca$CA$u[,1]
y<-o.ca$CA$u[,2]
plot(x,y)

#Anteilige Varianz, die durch die ersten beiden Achsen erklaert wird
o.ca$CA$eig[1:63]/sum(o.ca$CA$eig)

```




```{r NMDS, message=FALSE, eval=FALSE}
#NMDS----------

#Distanzmatrix als Start erzeugen
library(MASS)
library(vegan)

mde <-vegdist(sveg,method="euclidean")
mdm <-vegdist(sveg,method="manhattan")

#Zwei verschiedene NMDS-Methoden
set.seed(1) #macht man, wenn man bei einer Wiederholung exakt die gleichen Ergebnisse will
o.imds<-isoMDS(mde, k=2) # mit K = Dimensionen
set.seed(1)
o.mmds<-metaMDS(mde,k=3) # scheint nicht mit 2 Dimensionen zu konvergieren

plot(o.imds$points)
plot(o.mmds$points)

#Stress =  Abweichung der zweidimensionalen NMDS-Loesung von der originalen Distanzmatrix
stressplot(o.imds,mde)
stressplot(o.mmds,mde)

```


