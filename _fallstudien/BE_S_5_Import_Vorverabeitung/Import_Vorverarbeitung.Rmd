---
title: "KW 43: Import und Datenvorverarbeitung"
description:
author:
  - name: Adrian Hochreutener
output:
  distill::distill_article:
    self_contained: false
categories:
  - Biodiversity & Ecosystems (S)
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r include=FALSE}
# Benoetigte Bibliotheken ####
library(tidyverse) # Data wrangling und piping
library(lubridate) # Arbeiten mit Datumsformaten
library(data.table)# schnelles Dateneinlesen
library(ggpubr)    # to arrange multiple plots in one graph
library(PerformanceAnalytics) # Plotte Korrelationsmatrix
library(MuMIn)     # Multi-Model Inference
library(AICcmodavg)# Modellaverageing
library(fitdistrplus)# Prueft die Verteilung in Daten
library(lme4)      # Multivariate Modelle
library(blmeco)    # Bayesian data analysis using linear models
library(sjPlot)    # Plotten von Modellergebnissen (tab_model)
library(lattice)   # einfaches plotten von Zusammenhängen zwischen Variablen
```

# Aufgabe 1: Zähldaten

Die Projektstruktur steht. Nun können die Daten eingelesen und die nötigen Datentypen definiert werden. Das tidyverse-Universum ist dazu ganz zentral.

```{r out.width = "100%", fig.align ="center", echo = FALSE}
knitr::include_graphics("tidyverse.png")
```

Die Zaehldaten des Wildnispark Zürich wurden vorgaengig bereinigt. Z.B. wurden Stundenwerte entfernt, an denen am Zaehler Wartungsarbeiten stattgefunden haben. Das macht es fuer uns einfach, denn wir koennen die Daten ohne vorgaengige Bereinigung einfach einlesen.

Lest die Zaehlaten ein und sichtet den Datensatz.

```{r eval=FALSE}
depo <- read_csv("./HIER RELATIVEN DATEIPFAD EINGEBEN") 
# Je nach Bedarf muss der Speicherort sowie der Dateiname angepasst werden
```

_Hinweis zu den Daten:_
Im Stundenformat zeigen die Werte um 11:00 die Zähldaten zwischen 11:00 und 12:00.

## 1a) 

- Im Datensatz des Wildnisparks sind Datum und Uhrzeit in einer Spalte. Diese muessen getrennt werden.
Ich schlage hier den Ansatz des piping vor. Damit koennen in einem "Rutsch" mehrere Operationen ausgefuehrt werden.

- Ebenfalls muss das Datum als solches definiert werden. Welches Format hat es (format = "")?

- Schliesslich schneiden wir den Datensatz auf die Untersuchungsdauer zu.

```{r eval=FALSE}
str(depo)
depo <- depo %>%
  mutate(Datum_Uhrzeit = as.character(DatumUhrzeit)) %>%
  separate(Datum_Uhrzeit, into = c("Datum", "Zeit"), sep = " ")%>% # mit seperate() trennt man
                                                                   # 1 Spalte in 2.
  mutate(Datum = as.Date(Datum, format = "HIER DATUMSFORMAT")) %>% # hier wird Text zum Datumsformat
  # Schneide das df auf den gewuenschten Zeitraum zu
  filter(Datum >= depo_start, Datum <=  depo_end) # das Komma hat die gleiche Funktion wie ein &
```

## 1b) 

Ihr könnt selbst wählen, ob ihr Fussgänger:innen oder Velos untersuchen wollt.

- Entfernt die überflüssigen Spalten aus dem Datensatz.

## 1c) 

- Berechnen des Totals (IN + OUT), da dieses in den Daten nicht vorhanden ist (wiederum mit piping). 

Tipp: Wenn man R sagt: "addiere mir Spalte x mit Spalte y", dann macht R das fuer alle Zeilen in diesen zwei Spalten. Wenn man nun noch sagt: "speichere mir das Ergebnis dieser Addition in einer neuen Spalte namens __Total__", dann hat man die Aufgabe bereits geloest. Arbeitet mit __mutate()__).

- Entfernt nun alle NA-Werte mit __na.omit()__.

# Aufgabe 2: Meteodaten

## 2a) 

- Lest die Meteodaten ein und speichert sie unter __meteo__.

## 2b) 

- Auch hier muessen die Datentypen manuell gesetzt werden. 

Tipp: Das Datum wird als Integer erkannt. Zuerst muss es in Text umgewaldelt werden aus dem dann das eigentliche Datum herausgelesen werden kann. Das ist muehsam - darum hier der Code.

```{r eval=FALSE}
meteo <- transform(meteo, time = as.Date(as.character(time), "%Y%m%d"))
```

__Hinweis__ Was ist eigentlich Niederschlag:

https://www.meteoschweiz.admin.ch/home/wetter/wetterbegriffe/niederschlag.html

- Werden den anderen Spalten die richtigen Typen zugewiesen? Falls nicht, ändert die Datentypen.

- Nun schneiden wir den Datensatz auf die Untersuchungsdauer zu.

## 2c) 

- Jetzt muessen auch hier alle nicht verfuegbare Werte (NA's) herausgefiltert werden.

Tipp: Entweder geht das mit __na.omit()__ oder, etwas konservativer, koennen mit __filter()__ die Spalten genauer definiert werden. Mit folgendem Codeblock koennen z.B. alle Werte gefiltert werden, die in der Spalte stn nicht gleich NA sind (es werden also die Werte behalten, die vorhanden sind). Der Code muss für die anderen relevanten Spalten noch ergaenzt werden.

```{r eval=FALSE}
meteo <- meteo %>%
  filter(!is.na(stn))%>%
  ...%>%
  ...
```

- Prueft nun, wie die Struktur des data.frame (df) aussieht und ob alle NA Werte entfernt wurden. Stimmen alle Datentypen?

# Aufgabe 3: Datenvorverarbeitung (Mutationen)

## 3a) 

Jetzt fügen wir wahnsinnig viele Convinience Variabeln hinzu. Wir brauchen:

- Wochentag, der Befehl dazu ist __weekdays()__
  
Tipp: R sortiert die Levels aplhabetisch. Da das in unserem Fall aber sehr unpraktisch ist, müssen die Levels manuell bestimmt werden

```{r eval=FALSE}
  ...
  mutate(Wochentag = base::factor(Wochentag, 
                            levels = c("Montag", "Dienstag", "Mittwoch", 
                                       "Donnerstag", "Freitag", "Samstag", "Sonntag")))
  ...
```

- Ist es ein Werktag oder Wochenende?

```{r eval=FALSE}
  ...
  mutate(Wochenende = if_else(Wochentag == "Montag" | Wochentag == "Dienstag" | 
                           Wochentag == "Mittwoch" | Wochentag == "Donnerstag" | 
                           Wochentag == "Freitag", "Werktag", "Wochenende"))
  ...
```

Frage: Was bedeuten die | (zu erstellen mit AltGr + 7)? Welches ist das if Argument, welches das else?

- Kalenderwoche: __week()__
- Monat: __month()__
- Jahr: __year()__
- Vor oder nach COVID?

```{r eval= FALSE}
  ...
  mutate(COVID = if_else(Datum >= lock_1_start_2020, "covid", "normal"))
```

- Lockdown

Tipp: ich mache das nachgelagert, da ich die Erfahrung hatte, dass zu viele Operationen in einem Schritt auch schon mal etwas durcheinander erzeugen koennen. Hinweis II: Wir packen die beiden Lockdowns in eine Spalte --> long ist schöner als wide.

```{r eval=FALSE}
depo <- depo %>% 
mutate(Lockdown = if_else(Datum >= lock_1_start_2020 & Datum <= lock_1_end_2020,
                          "Lockdown_1",
                          if_else(Datum >= lock_2_start_2021 & Datum <= lock_2_end_2021,
                                  "Lockdown_2", "0"))) 
# hat das gepklappt?!
unique(depo$Lockdown)
```

Frage: Welches ist das if Argument, welches das else?

- Ändert die Datentypen der Spalten Wochenende, KW, Lockdown sowie COVID zu factor.

## 3b)

- Nun soll noch die volle Stunde als Integer im Datensatz stehen. Diese Angabe muss etwas muehsam aus den Daten gezogen werden (darum hier der fertige Code dazu):

```{r eval = FALSE}
depo$Stunde <- as.numeric(format(as.POSIXct(depo$Zeit,format="%H:%M"),"%H"))
```

## 3c) 

Die Daten wurden durch den WPZ kalibriert. Wir runden sie fuer unserer Analysen auf Ganzzahlen (unser Modell kann z. B. nicht mit Kommazahlen in der ahbängigen Variable umgehen). 

- Definieren sie sicherheitshalber als Ganzzahl (Integer)

- Macht das für IN, OUT und Total.

```{r eval=FALSE}
depo$... <- round(..., digits = 0)
depo$... <- as.integer(...)
```

# Aufgabe 4: Aggregierung der Stundendaten

## 4a) 

Unsere Daten liegen im Stundenformat vor. Fuer einige Auswertungen muessen wir aber auf ganze Tage zurueckgreifen koennen. 

- Die Stundendaten muessen zu ganzen Tagen aggregiert werden. Macht das wiederum mit piping. Berechnet die Summen pro Nutzergruppe und Richtung pro Tag.

Tipp: Wenn man die Convinience Variablen als grouping variable einspeisst, dann werden sie in das neue df uebernommen und muessen nicht nochmals hinzugefuegt werden

```{r eval=FALSE}
depo_d <- depo %>% 
  group_by(VARIABLE1, VARIABLE2, ...) %>%   # Gruppieren nach den Variablen
  summarise(Total = sum(Fuss_IN + Fuss_OUT),# Berechnen der gewünschten Werte
            Fuss_IN = sum(Fuss_IN),
            ...
```

## 4b)

- Aggregiere die Stundenwerte nach dem Jahr und Monat.

Tipp: Braucht wiederum __group_by()__ und __summarise()__. Nun brauchen wir nur noch das Total, keine Richtungstrennung mehr.

- Fügt den neu erstellten df eine Spalte mit Jahr und Monat hinzu. Das ist etwas mühsam, darum hier der fertige Code dazu:

```{r eval = FALSE}
# sortiere das df aufsteigend (nur das es sicher stimmt)
depo_m <- as.data.frame(depo_m)
depo_m[
  with(depo_m, order(Jahr, Monat)),]
# mache dann aus Jahr und Monat faktoren
depo_m <- depo_m %>% 
  mutate(Jahr = as.factor(Jahr)) %>% 
  mutate(Monat = as.factor(Monat)) %>% 
  mutate(Ym = paste(Jahr, Monat)) %>% # und mache eine neue Spalte, in der Jahr und
  mutate(Ym= factor(Ym, levels=unique(Ym))) # Monat in zusammen sind
```

## 4c)

Macht euch mit den Daten vertraut. Plottet sie, sehr euch die df's an, versteht, was sie repräsentieren.

Z.B. sind folgende Befehle und Plots wichtig:

- str()
- summarize()
- head()

- Scatterplot, x = Datum, y = Anzahl pro Zeiteinheit
- Histrogram
- usw.
__Nun sind alle Daten vorbereitet. Der naechste Schritt ist die Analyse.__
